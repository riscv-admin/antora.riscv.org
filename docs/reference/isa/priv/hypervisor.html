<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: RISC-V Ratified Specifications Library</title>
    <link rel="prev" href="sscofpmf.html">
    <link rel="next" href="priv-cfi.html">
    <meta name="generator" content="Antora 3.1.12">
    <script>
!function (theme, navWidth) {
  if (theme === 'dark') document.documentElement.classList.add('dark-theme')
  if (navWidth) document.documentElement.style.setProperty('--nav-width', `${navWidth}px`)
}(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: light)')?.matches && 'light'),
  localStorage && localStorage.getItem('nav-width'))
    </script>
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="stylesheet" href="../../_/css/vendor/search.css">
    <link rel="stylesheet" href="../../_/css/vendor/page-search.css">
    <link rel="stylesheet" href="../../_/css/vendor/spring-tabs.css">

    <meta name="antora-ui-version" content="1ea0d9f81bc80a15c1f560d76c5d8bddea1856e2"> 
    <meta name="version" content="">
    <meta name="component" content="isa">
    <meta name="latest-version" content="false">
    <link rel="icon" href="../../_/favicon.ico" type="image/x-icon">
  </head>
  <body class="article">


<header class="header" id="antora-header">
    <nav class="navbar">
        <head>
            <link data-rh="true" rel="icon" href="/img/favicon.ico">
            <link data-rh="true" rel="canonical" href="https://developer.riscv.org/ref">
            <link data-rh="true" rel="alternate" href="https://developer.riscv.org/ref" hreflang="en">
            <link data-rh="true" rel="alternate" href="https://developer.riscv.org/ref" hreflang="x-default">
            <link data-rh="true" rel="preconnect" href="https://MGVPU7BN22-dsn.algolia.net" crossorigin="anonymous">
            <link rel="stylesheet" type="text/css" href="/docs/reference/_/docusaurus-styles-copy-08-25.css">

        </head>
        <script>
            !function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())
        </script>
            <link rel="preload" as="image" href="/img/logo.svg">
            <div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div>
            <div class="announcementBar_mb4j" role="banner">
                <div class="announcementBarPlaceholder_vyr4"></div>
                <div class="content_knG7 announcementBarContent_xLdY">congratulations, you found the RISC-V Developer Portal! ðŸŽ‰ . This site is under active development and not meant for public consumption yet.</div><button type="button" aria-label="Close" class="clean-btn close closeButton_CVFx announcementBarClose_gvF7"><svg viewBox="0 0 15 15" width="14" height="14"><g stroke="currentColor" stroke-width="3.1"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div>
            <nav aria-label="Main" class="navbar ">
                <div class="navbar__inner">
                    <div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button>
                        <a class="navbar__brand" href="/">
                            <div class="navbar__logo"><img src="/img/logo.svg" alt="RISC-V Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="RISC-V Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Home</b></a>
                        <div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Specifications</a>
                            <ul class="dropdown__menu">
                                <li><a class="dropdown__link" href="/docs/spec/isa">ISA</a></li>
                                <li><a class="dropdown__link" href="/docs/spec/profiles">Profiles</a></li>
                                <li><a class="dropdown__link" docid="spec/non-isa" href="/docs/spec/non-isa">Non-ISA</a></li>
                            </ul>
                        </div>
                        <div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Developers</a>
                            <ul class="dropdown__menu">
                                <li><a class="dropdown__link" href="/docs/spec/intro">Specification Developers</a></li>
                                <li><a class="dropdown__link" href="/docs/hardware/overview">Hardware Developers</a></li>
                                <li><a class="dropdown__link" href="/docs/software/overview">Software Developers</a></li>
                            </ul>
                        </div><a class="navbar__item navbar__link" href="/blog">Blog</a><a href="https://riscv.org/community/calendar/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Events<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div>
                        <div class="navbar-item search hide-for-print">
                          <div id="search-field" class="field">
                            <input id="search-input" type="text" placeholder="Search">
                          </div>
                        </div>
                    <div class="navbar__items navbar__items--right">


                      <div class="navbarSearchContainer_Bca1">

                      </div>
                    </div>
                </div>
                <div role="presentation" class="navbar-sidebar__backdrop"></div>
            </nav>
            <div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper__tJE"></div>
        

    </nav>
</header><div class="body">
<div class="nav-container" data-component="isa" data-version="">
  <aside class="nav">
    <div class="panels">
      <div class="nav-panel-menu is-active" data-panel="menu">
        <nav class="nav-menu">
<div class="context">
  <span class="title">ISA Specifications</span>
  <span class="version">default</span>
  <button class="browse-version" id="browse-version">
    <svg
      height="24px"
      id="Layer_1"
      style="enable-background:new 0 0 512 512;"
      version="1.1"
      viewBox="0 0 512 512"
      width="24px"
      xml:space="preserve"
    ><g><path
          d="M256,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S273.7,224,256,224L256,224z"
        ></path><path
          d="M128.4,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S146,224,128.4,224L128.4,224z"
        ></path><path
          d="M384,224c-17.7,0-32,14.3-32,32s14.3,32,32,32s32-14.3,32-32S401.7,224,384,224L384,224z"
        ></path></g></svg>
  </button>
  </div><ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Volume I: RISC-V Unprivileged ISA Specification</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/colophon.html">Preface</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/rv32.html">RV32I Base Integer Instruction Set</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/rv32e.html">RV32E and RV64E Base Integer Instruction Sets, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/rv64.html">RV64I Base Integer Instruction Set</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/zifencei.html">"Zifencei" Extension for Instruction-Fetch Fence, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/zicsr.html">"Zicsr", Extension for Control and Status Register (CSR) Instructions, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/counters.html">"Zicntr" and "Zihpm" Extensions for Counters, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/zihintntl.html">"Zihintntl" Extension for Non-Temporal Locality Hints, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/zihintpause.html">"Zihintpause" Extension for Pause Hint, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/zimop.html">"Zimop" Extension for May-Be-Operations, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/zicond.html">"Zicond" Extension for Integer Conditional Operations, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/m-st-ext.html">"M" Extension for Integer Multiplication and Division, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/a-st-ext.html">"A" Extension for Atomic Instructions, Version 2.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/zawrs.html">"Zawrs" Extension for Wait-on-Reservation-Set instructions, Version 1.01</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/zacas.html">"Zacas" Extension for Atomic Compare-and-Swap (CAS) Instructions, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/zabha.html">"Zabha" Extension for Byte and Halfword Atomic Memory Operations, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/rvwmo.html">RVWMO Memory Consistency Model, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/ztso-st-ext.html">"Ztso" Extension for Total Store Ordering, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/cmo.html">"CMO" Extensions for Base Cache Management Operation ISA, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/f-st-ext.html">"F" Extension for Single-Precision Floating-Point, Version 2.2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/d-st-ext.html">"D" Extension for Double-Precision Floating-Point, Version 2.2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/q-st-ext.html">"Q" Extension for Quad-Precision Floating-Point, Version 2.2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/zfh.html">"Zfh" and "Zfhmin" Extensions for Half-Precision Floating-Point, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/bfloat16.html">"BF16" Extensions for for BFloat16-precision Floating-Point, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/zfa.html">"Zfa" Extension for Additional Floating-Point Instructions, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/zfinx.html">"Zfinx", "Zdinx", "Zhinx", "Zhinxmin" Extensions for Floating-Point in Integer Registers, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/c-st-ext.html">"C" Extension for Compressed Instructions, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/zc.html">"Zc*" Extension for Code Size Reduction, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/b-st-ext.html">"B" Extension for Bit Manipulation, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/v-st-ext.html">"V" Standard Extension for Vector Operations, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/scalar-crypto.html">Cryptography Extensions: Scalar &amp; Entropy Source Instructions, Version 1.0.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/vector-crypto.html">Cryptography Extensions: Vector Instructions, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/unpriv-cfi.html">Control-flow Integrity (CFI)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/rv-32-64g.html">RV32/64G Instruction Set Listings</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/naming.html">ISA Extension Naming Conventions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/mm-eplan.html">Appendix A: RVWMO Explanatory Material, Version 0.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/mm-formal.html">Appendix B: Formal Memory Model Specifications, Version 0.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/vector-examples.html">Appendix C: Vector Assembly Code Examples</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../unpriv/calling-convention.html">Appendix D: Calling Convention for Vector State (Not authoritative - Placeholder Only)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Volume II: RISC-V Privileged ISA Specification</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="priv-index.html">Privileged Architecture</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="priv-contributors.html">Contributors</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="priv-preface.html">Preface</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="priv-intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="priv-csrs.html">Control and Status Registers (CSRs)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="machine.html">Machine-Level ISA, Version 1.13</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="smstateen.html">"Smstateen/Ssstateen" Extensions, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="indirect-csr.html">"Smcsrind/Sscsrind" Indirect CSR Access, version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="#smepmp.adoc">"Smepmp" Extension for PMP Enhancements, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="smcntrpmf.html">"Smcntrpmf" Cycke and Instret Privilege Mode Filtering, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="rnmi.html">"Smrnmi" Extension for Resumable Non-Maskable Interrupts, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="smcdeleg.html">"Smcdeleg" Counter Delegation Extension, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="smdbltrp.html">"Smdbltrp" Double Trap Extension, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="smctr.html">"Smctr" Control Transfer Records Extension, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="supervisor.html">Supervisor-Level ISA, Version 1.13</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="sstc.html">"Sstc" Extension for Supervisor-mode Timer Interrupts, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="sscofpmf.html">"Sscofpmf" Extension for Count Overflow and Mode-Based Filtering, Version 1.0</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link"  href="hypervisor.html">"H" Extension for Hypervisor Support, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="priv-cfi.html">Control-flow Integrity(CFI)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="ssdbltrp.html">"Ssdbltrp" Double Trap Extension, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zpm.html">Pointer Masking Extensions, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="priv-insns.html">RISC-V Privileged Instruction Set Listings</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="priv-history.html">History</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="bibliography.html">Bibliography</a>
  </li>
</ul>
  </li>
</ul>
          <div class="toggle-sm">
            <button id="nav-toggle-2" class="nav-toggle"></button>
          </div>
        </nav>
      </div>
      <div class="nav-collapse">
        <button id="nav-collapse-toggle"><span></span></button>        
      </div>
    </div>
    <div class="nav-resize"></div>
  </aside>
</div>
<script>
!function (sidebar) {
  if (sidebar) {
    document.body.classList.add('nav-sm')
  }
}(localStorage && localStorage.getItem('sidebar') === 'close')
</script><main class="article">
<div class="toolbar" role="navigation">
  <button id="nav-toggle-1" class="nav-toggle"></button>
</div>
  <div class="content">
<aside class="sidebar">
  <div class="content">
    <div
      class="toc"
      data-title=""
      data-levels="2"
    >
      <div class="toc-menu"></div>
    </div>
    <div class="sidebar-links">
    </div>
  </div>
</aside>
<article class="doc">
<div class="breadcrumbs-container">
  <nav class="breadcrumbs" aria-label="breadcrumbs">
    <ul>
      <li><a href="../index.html">ISA Specifications</a></li>
      <li>Volume II: RISC-V Privileged ISA Specification</li>
      <li><a href="hypervisor.html">"H" Extension for Hypervisor Support, Version 1.0</a></li>
    </ul>
  </nav>
</div><div class="sect1">
<h2 id="hypervisor"><a class="anchor" href="#hypervisor"></a>"H" Extension for Hypervisor Support, Version 1.0</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes the RISC-V hypervisor extension, which
virtualizes the supervisor-level architecture to support the efficient
hosting of guest operating systems atop a type-1 or type-2 hypervisor.
The hypervisor extension changes supervisor mode into
<em>hypervisor-extended supervisor mode</em> (HS-mode, or <em>hypervisor mode</em> for
short), where a hypervisor or a hosting-capable operating system runs.
The hypervisor extension also adds another stage of address translation,
from <em>guest physical addresses</em> to supervisor physical addresses, to
virtualize the memory and memory-mapped I/O subsystems for a guest
operating system. HS-mode acts the same as S-mode, but with additional
instructions and CSRs that control the new stage of address translation
and support hosting a guest OS in virtual S-mode (VS-mode). Regular
S-mode operating systems can execute without modification either in
HS-mode or as VS-mode guests.</p>
</div>
<div class="paragraph">
<p>In HS-mode, an OS or hypervisor interacts with the machine through the
same SBI as an OS normally does from S-mode. An HS-mode hypervisor is
expected to implement the SBI for its VS-mode guest.</p>
</div>
<div class="paragraph">
<p>The hypervisor extension depends on an "I" base integer ISA with 32
<code>x</code> registers (RV32I or RV64I), not RV32E or RV64E, which have only 16 <code>x</code>
registers. CSR <code>mtval</code> must not be read-only zero, and standard
page-based address translation must be supported, either Sv32 for RV32,
or a minimum of Sv39 for RV64.</p>
</div>
<div class="paragraph">
<p>The hypervisor extension is enabled by setting bit 7 in the <code>misa</code> CSR,
which corresponds to the letter H. RISC-V harts that implement the
hypervisor extension are encouraged not to hardwire <code>misa</code>[7], so that
the extension may be disabled.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The baseline privileged architecture is designed to simplify the use of
classic virtualization techniques, where a guest OS is run at
user-level, as the few privileged instructions can be easily detected
and trapped. The hypervisor extension improves virtualization
performance by reducing the frequency of these traps.</p>
</div>
<div class="paragraph">
<p>The hypervisor extension has been designed to be efficiently emulable on
platforms that do not implement the extension, by running the hypervisor
in S-mode and trapping into M-mode for hypervisor CSR accesses and to
maintain shadow page tables. The majority of CSR accesses for type-2
hypervisors are valid S-mode accesses so need not be trapped.
Hypervisors can support nested virtualization analogously.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="privilege-modes"><a class="anchor" href="#privilege-modes"></a>Privilege Modes</h3>
<div class="paragraph">
<p>The current <em>virtualization mode</em>, denoted V, indicates whether the hart
is currently executing in a guest. When V=1, the hart is either in
virtual S-mode (VS-mode), or in virtual U-mode (VU-mode) atop a guest OS
running in VS-mode. When V=0, the hart is either in M-mode, in HS-mode,
or in U-mode atop an OS running in HS-mode. The virtualization mode also
indicates whether two-stage address translation is active (V=1) or
inactive (V=0). <a href="#HPrivModes">Privilege modes with the hypervisor extension.</a> lists the
possible privilege modes of a RISC-V hart with the hypervisor extension.</p>
</div>
<div style="page-break-after: always;"></div>
<table id="HPrivModes" class="tableblock frame-all grid-all stretch center">
<caption class="title">Table 1. Privilege modes with the hypervisor extension.</caption>
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Virtualization<br>
Mode (V)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Nominal Privilege</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Abbreviation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Two-Stage Translation</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<br>
0<br>
0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">U<br>
S<br>
M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U-mode<br>
HS-mode<br>
M-mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">User mode<br>
Hypervisor-extended supervisor mode<br>
Machine mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Off<br>
Off<br>
Off</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<br>
1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">U<br>
S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VU-mode<br>
VS-mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Virtual user mode<br>
Virtual supervisor mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">On<br>
On</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For privilege modes U and VU, the <em>nominal privilege mode</em> is U, and for
privilege modes HS and VS, the nominal privilege mode is S.</p>
</div>
<div class="paragraph">
<p>HS-mode is more privileged than VS-mode, and VS-mode is more privileged
than VU-mode. VS-mode interrupts are globally disabled when executing in
U-mode.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This description does not consider the possibility of U-mode or VU-mode
interrupts and will be revised if an extension for user-level interrupts
is adopted.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="hypervisor-and-virtual-supervisor-csrs"><a class="anchor" href="#hypervisor-and-virtual-supervisor-csrs"></a>Hypervisor and Virtual Supervisor CSRs</h3>
<div class="paragraph">
<p>An OS or hypervisor running in HS-mode uses the supervisor CSRs to
interact with the exception, interrupt, and address-translation
subsystems. Additional CSRs are provided to HS-mode, but not to VS-mode,
to manage two-stage address translation and to control the behavior of a
VS-mode guest: <code>hstatus</code>, <code>hedeleg</code>, <code>hideleg</code>, <code>hvip</code>, <code>hip</code>, <code>hie</code>,
<code>hgeip</code>, <code>hgeie</code>, <code>henvcfg</code>, <code>henvcfgh</code>, <code>hcounteren</code>, <code>htimedelta</code>,
<code>htimedeltah</code>, <code>htval</code>, <code>htinst</code>, and <code>hgatp</code>.</p>
</div>
<div class="paragraph">
<p>Furthermore, several <em>virtual supervisor</em> CSRs (VS CSRs) are replicas of
the normal supervisor CSRs. For example, <code>vsstatus</code> is the VS CSR that
duplicates the usual <code>sstatus</code> CSR.</p>
</div>
<div class="paragraph">
<p>When V=1, the VS CSRs substitute for the corresponding supervisor CSRs,
taking over all functions of the usual supervisor CSRs except as
specified otherwise. Instructions that normally read or modify a
supervisor CSR shall instead access the corresponding VS CSR. When V=1,
an attempt to read or write a VS CSR directly by its own separate CSR
address causes a virtual-instruction exception. (Attempts from U-mode
cause an illegal-instruction exception as usual.) The VS CSRs can be
accessed as themselves only from M-mode or HS-mode.</p>
</div>
<div class="paragraph">
<p>While V=1, the normal HS-level supervisor CSRs that are replaced by VS
CSRs retain their values but do not affect the behavior of the machine
unless specifically documented to do so. Conversely, when V=0, the VS
CSRs do not ordinarily affect the behavior of the machine other than
being readable and writable by CSR instructions.</p>
</div>
<div class="paragraph">
<p>Some standard supervisor CSRs (<code>senvcfg</code>, <code>scounteren</code>, and <code>scontext</code>,
possibly others) have no matching VS CSR. These supervisor CSRs continue
to have their usual function and accessibility even when V=1, except
with VS-mode and VU-mode substituting for HS-mode and U-mode. Hypervisor
software is expected to manually swap the contents of these registers as
needed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Matching VS CSRs exist only for the supervisor CSRs that must be
duplicated, which are mainly those that get automatically written by
traps or that impact instruction execution immediately after trap entry
and/or right before SRET, when software alone is unable to swap a CSR at
exactly the right moment. Currently, most supervisor CSRs fall into this
category, but future ones might not.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this chapter, we use the term <em>HSXLEN</em> to refer to the effective XLEN
when executing in HS-mode, and <em>VSXLEN</em> to refer to the effective XLEN
when executing in VS-mode.</p>
</div>
<div class="sect3">
<h4 id="sec:hstatus"><a class="anchor" href="#sec:hstatus"></a>Hypervisor Status (<code>hstatus</code>) Register</h4>
<div class="paragraph">
<p>The <code>hstatus</code> register is an HSXLEN-bit read/write register formatted as
shown in <a href="#hstatusreg-rv32">Hypervisor status register (<code>hstatus</code>) when HSXLEN=32</a> when HSXLEN=32
and <a href="#hstatusreg">Hypervisor status register (<code>hstatus</code>) when HSXLEN=64.</a> when HSXLEN=64. The <code>hstatus</code>
register provides facilities analogous to the <code>mstatus</code> register for
tracking and controlling the exception behavior of a VS-mode guest.</p>
</div>
<div id="hstatusreg-rv32" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UlAw1VHIS8xNtVJQDw8I8lSv1UGSM4TLhQU7ueKScw9zxCUVHBCGRyoAl5xHKKqMER43miHc6O7q6Ue8RiTPhYT54pYLxy0VHIQqZ4lhXayOQnJ-XlpmulV1TmJeKlAR0EkZxQWJyalWhgZGJrW1ANOdb6U=?id=hstatusreg-rv32" alt="Hypervisor status register (`hstatus`) when HSXLEN=32">
</div>
<div class="title">Figure 1. Hypervisor status register (<code>hstatus</code>) when HSXLEN=32</div>
</div>
<div id="hstatusreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UlAw1VHIS8xNtVJQDw8I8lSv1UGSM4TLhQU7ueKScw9zxCUVHBCGRyoAl5xHKKqMER43miHc6O7q6Ue8RiTPhYT54pYLxy0VHIQqZ4nHOiOksIzwQZEzNCFKn0dogK8vIY2xOgrJ-XlpmelW1TmJealARUA1GcUFicmpVoYGRia1tQBGf46p?id=hstatusreg" alt="Hypervisor status register (`hstatus`) when HSXLEN=64.">
</div>
<div class="title">Figure 2. Hypervisor status register (<code>hstatus</code>) when HSXLEN=64.</div>
</div>
<div class="paragraph">
<p>The VSXL field controls the effective XLEN for VS-mode (known as
VSXLEN), which may differ from the XLEN for HS-mode (HSXLEN). When
HSXLEN=32, the VSXL field does not exist, and VSXLEN=32. When HSXLEN=64,
VSXL is a <strong>WARL</strong> field that is encoded the same as the MXL field of <code>misa</code>,
shown in <a href="#misabase">[misabase]</a>. In particular, an
implementation may make VSXL be a read-only field whose value always
ensures that VSXLEN=HSXLEN.</p>
</div>
<div class="paragraph">
<p>If HSXLEN is changed from 32 to a wider width, and if field VSXL is not
restricted to a single value, it gets the value corresponding to the
widest supported width not wider than the new HSXLEN.</p>
</div>
<div class="paragraph">
<p>The <code>hstatus</code> fields VTSR, VTW, and VTVM are defined analogously to the
<code>mstatus</code> fields TSR, TW, and TVM, but affect execution only in VS-mode,
and cause virtual-instruction exceptions instead of illegal-instruction
exceptions. When VTSR=1, an attempt in VS-mode to execute SRET raises a
virtual-instruction exception. When VTW=1 (and assuming <code>mstatus</code>.TW=0),
an attempt in VS-mode to execute WFI raises a virtual-instruction
exception if the WFI does not complete within an
implementation-specific, bounded time limit. An implementation may have
WFI always raise a virtual-instruction exception in VS-mode when VTW=1
(and <code>mstatus</code>.TW=0), even if there are pending globally-disabled
interrupts when the instruction is executed. When VTVM=1, an attempt in
VS-mode to execute SFENCE.VMA or SINVAL.VMA or to access CSR <code>satp</code>
raises a virtual-instruction exception.</p>
</div>
<div class="paragraph">
<p>The VGEIN (Virtual Guest External Interrupt Number) field selects a
guest external interrupt source for VS-level external interrupts. VGEIN
is a <strong>WLRL</strong> field that must be able to hold values between zero and the
maximum guest external interrupt number (known as GEILEN), inclusive.
When VGEIN=0, no guest external interrupt source is selected for
VS-level external interrupts. GEILEN may be zero, in which case VGEIN
may be read-only zero. Guest external interrupts are explained in
<a href="#hgeinterruptregs">Hypervisor Guest External Interrupt Registers (<code>hgeip</code> and <code>hgeie</code>)</a>, and the use of VGEIN is covered
further in <a href="#hinterruptregs">Hypervisor Interrupt (<code>hvip</code>, <code>hip</code>, and <code>hie</code>) Registers</a>.</p>
</div>
<div class="paragraph">
<p>Field HU (Hypervisor in U-mode) controls whether the virtual-machine
load/store instructions, HLV, HLVX, and HSV, can be used also in U-mode.
When HU=1, these instructions can be executed in U-mode the same as in
HS-mode. When HU=0, all hypervisor instructions cause an
illegal-instruction exception in U-mode.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The HU bit allows a portion of a hypervisor to be run in U-mode for
greater protection against software bugs, while still retaining access
to a virtual machineâ€™s memory.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The SPV bit (Supervisor Previous Virtualization mode) is written by the
implementation whenever a trap is taken into HS-mode. Just as the SPP
bit in <code>sstatus</code> is set to the (nominal) privilege mode at the time of
the trap, the SPV bit in <code>hstatus</code> is set to the value of the
virtualization mode V at the time of the trap. When an SRET instruction
is executed when V=0, V is set to SPV.</p>
</div>
<div class="paragraph">
<p>When V=1 and a trap is taken into HS-mode, bit SPVP (Supervisor Previous
Virtual Privilege) is set to the nominal privilege mode at the time of
the trap, the same as <code>sstatus</code>.SPP. But if V=0 before a trap, SPVP is
left unchanged on trap entry. SPVP controls the effective privilege of
explicit memory accesses made by the virtual-machine load/store
instructions, HLV, HLVX, and HSV.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Without SPVP, if instructions HLV, HLVX, and HSV looked instead to
<code>sstatus</code>.SPP for the effective privilege of their memory accesses,
then, even with HU=1, U-mode could not access virtual machine memory at
VS-level, because to enter U-mode using SRET always leaves SPP=0. Unlike
SPP, field SPVP is untouched by transitions back-and-forth between
HS-mode and U-mode.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Field GVA (Guest Virtual Address) is written by the implementation
whenever a trap is taken into HS-mode. For any trap (breakpoint, address
misaligned, access fault, page fault, or guest-page fault) that writes a
guest virtual address to <code>stval</code>, GVA is set toÂ 1. For any other trap
into HS-mode, GVA is set toÂ 0.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For breakpoint and memory access traps that write a nonzero value to
<code>stval</code>, GVA is redundant with field SPV (the two bits are set the same)
except when the explicit memory access of an HLV, HLVX, or HSV
instruction causes a fault. In that case, SPV=0 but GVA=1.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The VSBE bit is a <strong>WARL</strong> field that controls the endianness of explicit memory
accesses made from VS-mode. If VSBE=0, explicit load and store memory
accesses made from VS-mode are little-endian, and if VSBE=1, they are
big-endian. VSBE also controls the endianness of all implicit accesses
to VS-level memory management data structures, such as page tables. An
implementation may make VSBE a read-only field that always specifies the
same endianness as HS-mode.</p>
</div>
</div>
<div class="sect3">
<h4 id="hypervisor-trap-delegation-hedeleg-and-hideleg-registers"><a class="anchor" href="#hypervisor-trap-delegation-hedeleg-and-hideleg-registers"></a>Hypervisor Trap Delegation (<code>hedeleg</code> and <code>hideleg</code>) Registers</h4>
<div class="paragraph">
<p>Register <code>hedeleg</code> is a 64-bit read/write register, formatted as shown in
<a href="#hedelegreg">Hypervisor exception delegation register (<code>hedeleg</code>).</a>.
Register <code>hideleg</code> is an HSXLEN-bit read/write register, formatted as shown in
<a href="#hidelegreg">Hypervisor interrupt delegation register (<code>hideleg</code>).</a>.
By default, all traps at
any privilege level are handled in M-mode, though M-mode usually uses
the <code>medeleg</code> and <code>mideleg</code> CSRs to delegate some traps to HS-mode. The
<code>hedeleg</code> and <code>hideleg</code> CSRs allow these traps to be further delegated
to a VS-mode guest; their layout is the same as <code>medeleg</code> and <code>mideleg</code>.</p>
</div>
<div id="hedelegreg" class="paragraph">
<div class="title">Hypervisor exception delegation register (<code>hedeleg</code>).</div>
<p>bytefield/hedelegreg.edn[]</p>
</div>
<div id="hidelegreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqVUT1PwzAU3PsrnjwlQpbyUTFkYwAVqTDAABJieGmcJqpjW_arUqjy33FoWrVNkcpk-Z7v3vkuKESJRNZBZiTWCj6Gc5uVWhEvsanlF7CnG4gNPKCUOS5WDHZTV38LSKbdZzgJvBBY3fJK1MuKYBrBCYiFsLxUoGo54FKUxBu0S78tjfaPe_IIzfVGOG68gheDNAknHrfYcj8ANnt9n98_85h5086ggvgWMhIb4qgWlbbAHKElbzrX1ttw264LjwWiv5lCFWe8Y-KjImHt2pC7ViEjbfY3vlZWSCRR9AiRbi5N-pjG-OkPgn4jsODt7mUeeitDPe2uCpZrWZxXFl4d1v8t_5Z42fO4t0NyaXLYCX3SP9yz4DQ=?id=hidelegreg" alt="Hypervisor interrupt delegation register (`hideleg`).">
</div>
<div class="title">Figure 3. Hypervisor interrupt delegation register (<code>hideleg</code>).</div>
</div>
<div class="paragraph">
<p>A synchronous trap that has been delegated to HS-mode (using <code>medeleg</code>)
is further delegated to VS-mode if V=1 before the trap and the
corresponding <code>hedeleg</code> bit is set. Each bit of <code>hedeleg</code> shall be
either writable or read-only zero. Many bits of <code>hedeleg</code> are required
specifically to be writable or zero, as enumerated in
<a href="#hedeleg-bits">Bits of <code>hedeleg</code> that must be writable or must be read-only zero.</a>. BitÂ 0, corresponding to
instruction address-misaligned exceptions, must be writable if
IALIGN=32.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Requiring that certain bits of <code>hedeleg</code> be writable reduces some of the
burden on a hypervisor to handle variations of implementation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When XLEN=32, <code>hedelegh</code> is a 32-bit read/write register
that aliases bits 63:32 of <code>hedeleg</code>.
Register <code>hedelegh</code> does not exist when XLEN=64.</p>
</div>
<div class="paragraph">
<p>An interrupt that has been delegated to HS-mode (using <code>mideleg</code>) is
further delegated to VS-mode if the corresponding <code>hideleg</code> bit is set.
Among bits 15:0 of <code>hideleg</code>, bits 10, 6, and 2 (corresponding to the
standard VS-level interrupts) are writable, and bits 12, 9, 5, and 1
(corresponding to the standard S-level interrupts) are read-only zeros.</p>
</div>
<div class="paragraph">
<p>When a virtual supervisor external interrupt (code 10) is delegated to
VS-mode, it is automatically translated by the machine into a supervisor
external interrupt (code 9) for VS-mode, including the value written to
<code>vscause</code> on an interrupt trap. Likewise, a virtual supervisor timer
interrupt (6) is translated into a supervisor timer interrupt (5) for
VS-mode, and a virtual supervisor software interrupt (2) is translated
into a supervisor software interrupt (1) for VS-mode. Similar
translations may or may not be done for platform interrupt
causes (codes 16 and above).</p>
</div>
<table id="hedeleg-bits" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 2. Bits of <code>hedeleg</code> that must be writable or must be read-only zero.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-top">Bit</th>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Corresponding Exception</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">0<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
15<br>
16<br>
18<br>
19<br>
20<br>
21<br>
22<br>
23</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(See text)<br>
Writable<br>
Writable<br>
Writable<br>
Writable<br>
Writable<br>
Writable<br>
Writable<br>
Writable<br>
Read-only 0<br>
Read-only 0<br>
Read-only 0<br>
Writable<br>
Writable<br>
Writable<br>
Read-only 0<br>
Writable<br>
Writable<br>
Read-only 0<br>
Read-only 0<br>
Read-only 0<br>
Read-only 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction address misaligned<br>
Instruction access fault<br>
Illegal instruction<br>
Breakpoint<br>
Load address misaligned<br>
Load access fault<br>
Store/AMO address misaligned<br>
Store/AMO access fault<br>
Environment call from U-mode or VU-mode<br>
Environment call from HS-mode<br>
Environment call from VS-mode<br>
Environment call from M-mode<br>
Instruction page fault<br>
Load page fault<br>
Store/AMO page fault<br>
Double trap<br>
Software check<br>
Hardware error<br>
Instruction guest-page fault<br>
Load guest-page fault<br>
Virtual instruction<br>
Store/AMO guest-page fault</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="hinterruptregs"><a class="anchor" href="#hinterruptregs"></a>Hypervisor Interrupt (<code>hvip</code>, <code>hip</code>, and <code>hie</code>) Registers</h4>
<div class="paragraph">
<p>Register <code>hvip</code> is an HSXLEN-bit read/write register that a hypervisor
can write to indicate virtual interrupts intended for VS-mode. Bits of
<code>hvip</code> that are not writable are read-only zeros.</p>
</div>
<div id="hvipreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqVUctOwzAQvPcrVj4lQpbShxDKjQMIpMIBJEBCHDaN00S4trXeKoWq_45D02cKiJPlWc_seCbKVYHM5CF1GisDr-25TAtrWBY4q_QHiLsz6Du4Rq0znLwLWE999algMFq9xb0oCAHZWpaqmpYMowQOQMwVycKAqXSLa1WwnCFNw7ZhsnnckDtoZhfKSxcUghgMB3Ev4IS1DAMQN48v46t72RfBtHdooH8OKasFSzST0hIIz0gcTGeWgg2_XK3ifYHkZ6Yy-RFvn_hUEc9Rw61hRTR37HdKF78qpWzd5ibnhpRGVnmDMNvZqUkTVxc__EnUbAQRPV8-jONgpa2pXlciMqvz4-rireHRH6H93_J3mac9d_vbJjccbHdCk_gXQVbjOw==?id=hvipreg" alt="Hypervisor virtual-interrupt-pending register(`hvip`).">
</div>
<div class="title">Figure 4. Hypervisor virtual-interrupt-pending register(<code>hvip</code>).</div>
</div>
<div class="paragraph">
<p>The standard portion (bits 15:0) of <code>hvip</code> is formatted as shown in
<a href="#hvipreg-standard">Standard portion (bits 15:0) of <code>hvip</code>.</a>. Bits VSEIP, VSTIP,
and VSSIP of <code>hvip</code> are writable. Setting VSEIP=1 in <code>hvip</code> asserts a
VS-level external interrupt; setting VSTIP asserts a VS-level timer
interrupt; and setting VSSIP asserts a VS-level software interrupt.</p>
</div>
<div id="hvipreg-standard" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq9ks9LwzAUx-_7Kx49rUigPzKdvU_wIAgTL-LhdU3WsiwpSWDT0f_diHNat4ysB0-Bl_f5vk_7Mq4YR2u1gaIV2Eh42Z-7gitpCcd1I94geriCtIU7FKLExSqCr1vTvDPIaPcaj8YuCLTakJo1y9oCTaBXxIppwiXIRuzrgnFL1qiXblqefDd_wkfVUm2ZIa1LcGGQZ_HI1TVuiLuAKJ1ETte0KIFCYdnWEpSLWmmIjEVtnW2ptJtvYNd1cQ9NvSiT1Tkw-Q36um4PTdmFYjde8rzXdYjWZLBWPlArC9FKB2sll2idBqf9xOf57P7xR9o3jv6lngZR81Dq9Banhy_0_1IastSg5fxLkvfBfABe73-b?id=hvipreg-standard" alt="Standard portion (bits 15:0) of `hvip`.">
</div>
<div class="title">Figure 5. Standard portion (bits 15:0) of <code>hvip</code>.</div>
</div>
<div class="paragraph">
<p>Registers <code>hip</code> and <code>hie</code> are HSXLEN-bit read/write registers that
supplement HS-levelâ€™s <code>sip</code> and <code>sie</code> respectively. The <code>hip</code> register
indicates pending VS-level and hypervisor-specific interrupts, while
<code>hie</code> contains enable bits for the same interrupts.</p>
</div>
<div id="hipreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqVUT1PwzAU3PsrnjwlQpbyUTFkYwAVqTDAABJieGmcJqpjW_arUqjy33FoWrVNkcpk-Z7v3vkuKESJRNZBZiTWCj6Gc5uVWhEvsanlF7CnG4gNPKCUOS5WDHZTV38LSKbdZzgJvBBY3fJK1MuKYBrBCYiFsLxUoGo54FKUxBu0S78tjfaPe_IIzfVGOG68gheDNAknHrfYcj8ANnt9n98_85h5086ggvgWMhIb4qgWlbbAHKElbzrX1ttw264LjwWiv5lCFWe8Y-KjImHt2pC7ViEjbfY3vlZWSCRR9AiRbi5N-pjG-OkPgn4jsODt7mUeeitDPe2uCpZrWZxXFl4d1v8t_5Z42fO4t0NyaXLYCX3SP9yz4DQ=?id=hipreg" alt="Hypervisor interrupt-pending register (`hip`).">
</div>
<div class="title">Figure 6. Hypervisor interrupt-pending register (<code>hip</code>).</div>
</div>
<div id="hiereg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqVUT1PwzAU3PsrnjwlQpbyUTFkYwAVqTDAABJieGmcJqpjW_arUqjy33FoWrVNkcpk-Z7v3vkuKESJRNZBZiTWCj6Gc5uVWhEvsanlF7CnG4gNPKCUOS5WDHZTV38LSKbdZzgJvBBY3fJK1MuKYBrBCYiFsLxUoGo54FKUxBu0S78tjfaPe_IIzfVGOG68gheDNAknHrfYcj8ANnt9n98_85h5086ggvgWMhIb4qgWlbbAHKElbzrX1ttw264LjwWiv5lCFWe8Y-KjImHt2pC7ViEjbfY3vlZWSCRR9AiRbi5N-pjG-OkPgn4jsODt7mUeeitDPe2uCpZrWZxXFl4d1v8t_5Z42fO4t0NyaXLYCX3SP9yz4DQ=?id=hiereg" alt="Hypervisor interrupt-enable register (`hie`).">
</div>
<div class="title">Figure 7. Hypervisor interrupt-enable register (<code>hie</code>).</div>
</div>
<div class="paragraph">
<p>For each writable bit in <code>sie</code>, the corresponding bit shall be read-only
zero in both <code>hip</code> and <code>hie</code>. Hence, the nonzero bits in <code>sie</code> and <code>hie</code>
are always mutually exclusive, and likewise for <code>sip</code> and <code>hip</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The active bits of <code>hip</code> and <code>hie</code> cannot be placed in HS-levelâ€™s <code>sip</code>
and <code>sie</code> because doing so would make it impossible for software to
emulate the hypervisor extension on platforms that do not implement it
in hardware.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An interrupt <em>i</em> will trap to HS-mode whenever all of the following are
true: (a) either the current operating mode is HS-mode and the SIE bit
in the <code>sstatus</code> register is set, or the current operating mode has less
privilege than HS-mode; (b) bit <em>i</em> is set in both <code>sip</code> and <code>sie</code>, or
in both <code>hip</code> and <code>hie</code>; and (c) bit <em>i</em> is not set in <code>hideleg</code>.</p>
</div>
<div class="paragraph">
<p>If bit <em>i</em> of <code>sie</code> is read-only zero, the same bit in register <code>hip</code>
may be writable or may be read-only. When bit <em>i</em> in <code>hip</code> is writable,
a pending interrupt <em>i</em> can be cleared by writing 0 to this bit. If
interrupt <em>i</em> can become pending in <code>hip</code> but bit <em>i</em> in <code>hip</code> is
read-only, then either the interrupt can be cleared by clearing bit <em>i</em>
of <code>hvip</code>, or the implementation must provide some other mechanism for
clearing the pending interrupt (which may involve a call to the
execution environment).</p>
</div>
<div class="paragraph">
<p>A bit in <code>hie</code> shall be writable if the corresponding interrupt can ever
become pending in <code>hip</code>. Bits of <code>hie</code> that are not writable shall be
read-only zero.</p>
</div>
<div class="paragraph">
<p>The standard portions (bits 15:0) of registers <code>hip</code> and <code>hie</code> are
formatted as shown in <a href="#hipreg-standard">Standard portion (bits 15:0) of <code>hip</code>.</a> and <a href="#hiereg-standard">Standard portion (bits 15:0) of <code>hie</code>.</a> respectively.</p>
</div>
<div id="hipreg-standard" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq1kFFLwzAUhd_3Ky55WpFAm1bFvk_xQRAqvogPt2u6lmVpSQKbjv53o5tC16WEqk-Be853cu-ZF7xEY5SGtBVYS3g5vvu0bKShJW5q8Qbk4QKiFm5RiByXawIHVdfvHFjSvQazuQ0C1WxpxetVZSAJoTfEgitaSpC1OM4FLw3doFrZ3-Lw2_wJD6Z5s-OatjbBhkHMgpmdK9xSKwCJLoldV7cogUFq-M5QlMuqUUC0QWXstnmj7P8a9l0X9NDYiXJZjIHsB0xGXJGXK_Rx3Uw-8nrijVc-a3117xLjMdGvwbGEcCAO1EN-H8vuFvePLtFJPWfTqCcfip1SmS81qPuk0bOFerX-J6b4H5LYL5OYK-kD4SGaVg==?id=hipreg-standard" alt="Standard portion (bits 15:0) of `hip`.">
</div>
<div class="title">Figure 8. Standard portion (bits 15:0) of <code>hip</code>.</div>
</div>
<div id="hiereg-standard" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq1kDFPwzAQhff-ilOmRshSYgdQs7cVA1MQC2K4NE4T4dqRbamFKv8dQwtSGhJZASZL9973fPfmBS_RWm0gbQTWEp7O7zEtlbSkxF0tXiG4v4K4gRUKkePmJYCTauo3DjRpn8PZ3AWBVntS8XpbWUgi6Ayx4JqUEmQtznPBS0t2qLfuNxZ9mT_g3jRXB25I4xJcGDAaztxc4544AYL4OnDrmgYlUEgtP1iCclMpDYGxqK3bNlfa_W_g2LZhB2WDKJfFGEi_wWTEFXu5Ih_XYvKRtxNvvPFZ67P7IZGNiX4NjiVEPbGnnvK7WLZe3i2HxEHqMZtGPfhQ9JLKfKle3ReN_lioV-t_YmL_kER_mUSHkt4Bk3GaKg==?id=hiereg-standard" alt="Standard portion (bits 15:0) of `hie`.">
</div>
<div class="title">Figure 9. Standard portion (bits 15:0) of <code>hie</code>.</div>
</div>
<div class="paragraph">
<p>Bits <code>hip</code>.SGEIP and <code>hie</code>.SGEIE are the interrupt-pending and
interrupt-enable bits for guest external interrupts at supervisor level
(HS-level). SGEIP is read-only in <code>hip</code>, and is 1 if and only if the
bitwise logical-AND of CSRs <code>hgeip</code> and <code>hgeie</code> is nonzero in any bit.
(See <a href="#hgeinterruptregs">Hypervisor Guest External Interrupt Registers (<code>hgeip</code> and <code>hgeie</code>)</a>.)</p>
</div>
<div class="paragraph">
<p>Bits <code>hip</code>.VSEIP and <code>hie</code>.VSEIE are the interrupt-pending and
interrupt-enable bits for VS-level external interrupts. VSEIP is
read-only in <code>hip</code>, and is the logical-OR of these interrupt sources:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>bit VSEIP of <code>hvip</code>;</p>
</li>
<li>
<p>the bit of <code>hgeip</code> selected by <code>hstatus</code>.VGEIN; and</p>
</li>
<li>
<p>any other platform-specific external interrupt signal directed to
VS-level.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Bits <code>hip</code>.VSTIP and <code>hie</code>.VSTIE are the interrupt-pending and
interrupt-enable bits for VS-level timer interrupts. VSTIP is read-only
in <code>hip</code>, and is the logical-OR of <code>hvip</code>.VSTIP and any other
platform-specific timer interrupt signal directed to VS-level.</p>
</div>
<div class="paragraph">
<p>Bits <code>hip</code>.VSSIP and <code>hie</code>.VSSIE are the interrupt-pending and
interrupt-enable bits for VS-level software interrupts. VSSIP in <code>hip</code>
is an alias (writable) of the same bit in <code>hvip</code>.</p>
</div>
<div class="paragraph">
<p>Multiple simultaneous interrupts destined for HS-mode are handled in the
following decreasing priority order: SEI, SSI, STI, SGEI, VSEI, VSSI,
VSTI, LCOFI.</p>
</div>
</div>
<div class="sect3">
<h4 id="hgeinterruptregs"><a class="anchor" href="#hgeinterruptregs"></a>Hypervisor Guest External Interrupt Registers (<code>hgeip</code> and <code>hgeie</code>)</h4>
<div class="paragraph">
<p>The <code>hgeip</code> register is an HSXLEN-bit read-only register, formatted as
shown in <a href="#hgeipreg">Hypervisor guest external interrupt-pending register (<code>hgeip</code>).</a>, that indicates pending guest
external interrupts for this hart. The <code>hgeie</code> register is an HSXLEN-bit
read/write register, formatted as shown in
<a href="#hgeiereg">Hypervisor guest external interrupt-enable register (<code>hgeie</code>).</a>, that contains enable bits for the
guest external interrupts at this hart. Guest external interrupt number
<em>i</em> corresponds with bitÂ <em>i</em> in both <code>hgeip</code> and <code>hgeie</code>.</p>
</div>
<div id="hgeipreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq1UMtqwzAQvOcrFp1sisB2fPI9fUDSSy-FkMM6WSWisiwkuUlb_O9d1y7Y9FyQkDQ7Mzur5EQKY_QBKmdQW9hP51elWhulwkabDxC7O8gd3KMxNR7fBIzVoD8JirI_pKuEjcC3V3khfb5EKDNYgHgiL5UFq82EG1JRNujP3G2d_ZIH8R-0bm8UpGMHNoN1McAer_LYmq6xk3vgzFPzolwGhMpgTSZA4umdmQR7kQkQOe__WI8vr9vNs_yxP6R9upry8hwgHjoKETa3SN6igSfLF9-5GAQPEBzy3HmfzhUcdfEe7Wd0qOrWj1_QL6X5wJoXvwFYaI5z?id=hgeipreg" alt="Hypervisor guest external interrupt-pending register (`hgeip`).">
</div>
<div class="title">Figure 10. Hypervisor guest external interrupt-pending register (<code>hgeip</code>).</div>
</div>
<div id="hgeiereg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq1kk1PwzAMhu_7FVZOrVCkdd0B9cZhfEiDAxxAmnZwW3erSJMqcdkA9b-Tbt20btwQUqo0dvz6sZ0gpwKZrYOkVlhqWPT7d1IYzbLAqlSfIB6vIKrhFpVKMXsXsPe68otgMm2X4SjwQmDNRq6pXK0ZpmMYGDEnKwsNulS9XVHBskK78tni8eFyF3xhTc2WnKy9gheDeNKZLW5kZlRT6V7deeY--WQ6BIREYUrKQWDpw98kWIixABH57z_W_cvbfPYkd_LLsA1HPa-vA8RdQ45htmWyGhU8aP9jm5qd8AW4GjVE15AwbVmiztbGgiCd-5anxvZldq07nGWjLSlkyn2QqX8zp4bZVJeetg1PwIIuJYjg9eZ5HorDA9jsOypSo_LzsYdH4PgM2DFaHiD_Ca0b1uC8b_AR8jjmHU0cnSQ-E4q6mFPnD1QU7cw=?id=hgeiereg" alt="Hypervisor guest external interrupt-enable register (`hgeie`).">
</div>
<div class="title">Figure 11. Hypervisor guest external interrupt-enable register (<code>hgeie</code>).</div>
</div>
<div class="paragraph">
<p>Guest external interrupts represent interrupts directed to individual
virtual machines at VS-level. If a RISC-V platform supports placing a
physical device under the direct control of a guest OS with minimal
hypervisor intervention (known as <em>pass-through</em> or <em>direct assignment</em>
between a virtual machine and the physical device), then, in such
circumstance, interrupts from the device are intended for a specific
virtual machine. Each bit of <code>hgeip</code> summarizes <em>all</em> pending interrupts
directed to one virtual hart, as collected and reported by an interrupt
controller. To distinguish specific pending interrupts from multiple
devices, software must query the interrupt controller.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Support for guest external interrupts requires an interrupt controller
that can collect virtual-machine-directed interrupts separately from
other interrupts.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The number of bits implemented in <code>hgeip</code> and <code>hgeie</code> for guest external
interrupts is UNSPECIFIED and may be zero. This number is known as <em>GEILEN</em>. The
least-significant bits are implemented first, apart from bit 0. Hence,
if GEILEN is nonzero, bits GEILEN:1 shall be writable in <code>hgeie</code>, and
all other bit positions shall be read-only zeros in both <code>hgeip</code> and
<code>hgeie</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The set of guest external interrupts received and handled at one
physical hart may differ from those received at other harts. Guest
external interrupt number <em>i</em> at one physical hart is typically expected
not to be the same as guest external interrupt <em>i</em> at any other hart.
For any one physical hart, the maximum number of virtual harts that may
directly receive guest external interrupts is limited by GEILEN. The
maximum this number can be for any implementation is 31 for RV32 and 63
for RV64, per physical hart.</p>
</div>
<div class="paragraph">
<p>A hypervisor is always free to <em>emulate</em> devices for any number of
virtual harts without being limited by GEILEN. Only direct pass-through
(direct assignment) of interrupts is affected by the GEILEN limit, and
the limit is on the number of virtual harts receiving such interrupts,
not the number of distinct interrupts received. The number of distinct
interrupts a single virtual hart may receive is determined by the
interrupt controller.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Register <code>hgeie</code> selects the subset of guest external interrupts that
cause a supervisor-level (HS-level) guest external interrupt. The enable
bits in <code>hgeie</code> do not affect the VS-level external interrupt signal
selected from <code>hgeip</code> by <code>hstatus</code>.VGEIN.</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:henvcfg"><a class="anchor" href="#sec:henvcfg"></a>Hypervisor Environment Configuration Register (<code>henvcfg</code>)</h4>
<div class="paragraph">
<p>The <code>henvcfg</code> CSR is a 64-bit read/write register, formatted
as shown in <a href="#henvcfg">Hypervisor environment configuration register (<code>henvcfg</code>).</a>, that controls
certain characteristics of the execution environment when virtualization
mode V=1.</p>
</div>
<div id="henvcfg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UlAw1FHIS8xNtVJQd_P091Wv1cEqFx4Q5IlLzifAFZdUcDCalBFcytnJE6c2ZydnNzySUahyRiZ4nImwMMAX1XdGpkT5ziXElZxAcXQJxakvwMkXt6HBIc5guVgdheT8vLTMdKvqnMS8VKAioDczigsSk1OtDA2MTGprAc6Lfow=?id=henvcfg" alt="Hypervisor environment configuration register (`henvcfg`).">
</div>
<div class="title">Figure 12. Hypervisor environment configuration register (<code>henvcfg</code>).</div>
</div>
<div class="paragraph">
<p>If bit FIOM (Fence of I/O implies Memory) is set to one in <code>henvcfg</code>,
FENCE instructions executed when V=1 are modified so the requirement to
order accesses to device I/O implies also the requirement to order main
memory accesses. <a href="#henvcfg-FIOM">Modified interpretation of FENCE predecessor and successor sets when FIOM=1 and virtualization mode V=1.</a> details the modified
interpretation of FENCE instruction bits PI, PO, SI, and SO when FIOM=1
and V=1.</p>
</div>
<div class="paragraph">
<p>Similarly, when FIOM=1 and V=1, if an atomic instruction that accesses a
region ordered as device I/O has its <em>aq</em> and/or <em>rl</em> bit set, then that
instruction is ordered as though it accesses both device I/O and memory.</p>
</div>
<table id="henvcfg-FIOM" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 3. Modified interpretation of FENCE predecessor and successor sets when FIOM=1 and virtualization mode V=1.</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Instruction bit</th>
<th class="tableblock halign-left valign-top">Meaning when set</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">PI<br>
PO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Predecessor device input and memory reads (PR implied)<br>
Predecessor device output and memory writes (PW implied)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">SI<br>
SO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Successor device input and memory reads (SR implied)<br>
Successor device output and memory writes (SW implied)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The PBMTE bit controls whether the Svpbmt extension is available for use
in VS-stage address translation. When PBMTE=1, Svpbmt is available for
VS-stage address translation. When PBMTE=0, the implementation behaves
as though Svpbmt were not implemented for VS-stage address translation.
If Svpbmt is not implemented, PBMTE is read-only zero.</p>
</div>
<div class="paragraph">
<p>If the Svadu extension is implemented, the ADUE bit controls whether hardware
updating of PTE A/D bits is enabled for VS-stage address translation.
When ADUE=1, hardware updating of PTE A/D bits is enabled during VS-stage
address translation, and the implementation behaves as though the Svade
extension were not implemented for VS-mode address translation.
When ADUE=0, the implementation behaves as though Svade were implemented for
VS-stage address translation.
If Svadu is not implemented, ADUE is read-only zero.</p>
</div>
<div class="paragraph">
<p>The definition of the STCE field is furnished by the Sstc extension.</p>
</div>
<div class="paragraph">
<p>The definition of the CBZE field is furnished by the Zicboz extension.</p>
</div>
<div class="paragraph">
<p>The definitions of the CBCFE and CBIE fields are furnished by the Zicbom extension.</p>
</div>
<div class="paragraph">
<p>The definition of the PMM field is furnished by the Ssnpm extension.</p>
</div>
<div class="paragraph">
<p>The Zicfilp extension adds the <code>LPE</code> field in <code>henvcfg</code>. When the <code>LPE</code> field
is set to 1, the Zicfilp extension is enabled in VS-mode. When the <code>LPE</code> field
is 0, the Zicfilp extension is not enabled in VS-mode and the following rules
apply to VS-mode:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The hart does not update the <code>ELP</code> state; it remains as <code>NO_LP_EXPECTED</code>.</p>
</li>
<li>
<p>The <code>LPAD</code> instruction operates as a no-op.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Zicfiss extension adds the <code>SSE</code> field in <code>henvcfg</code>. If the <code>SSE</code> field is
set to 1, the Zicfiss extension is activated in VS-mode. When the <code>SSE</code> field is
0, the Zicfiss extension remains inactive in VS-mode, and the following rules
apply when <code>V=1</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>32-bit Zicfiss instructions will revert to their behavior as defined by Zimop.</p>
</li>
<li>
<p>16-bit Zicfiss instructions will revert to their behavior as defined by Zcmop.</p>
</li>
<li>
<p>The <code>pte.xwr=010b</code> encoding in VS-stage page tables becomes reserved.</p>
</li>
<li>
<p>The <code>senvcfg.SSE</code> field will read as zero and is read-only.</p>
</li>
<li>
<p>When <code>menvcfg.SSE</code> is one, <code>SSAMOSWAP.W/D</code> raises a virtual-instruction
exception.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Ssdbltrp extension adds the double-trap-enable (<code>DTE</code>) field in <code>henvcfg</code>.
When <code>henvcfg.DTE</code> is zero, the implementation behaves as though Ssdbltrp is not
implemented for VS-mode and the <code>vsstatus.SDT</code> bit is read-only zero.</p>
</div>
<div class="paragraph">
<p>When XLEN=32, <code>henvcfgh</code> is a
32-bit read/write register that aliases bits 63:32
of <code>henvcfg</code>. Register <code>henvcfgh</code> does not exist when
XLEN=64.</p>
</div>
</div>
<div class="sect3">
<h4 id="hypervisor-counter-enable-hcounteren-register"><a class="anchor" href="#hypervisor-counter-enable-hcounteren-register"></a>Hypervisor Counter-Enable (<code>hcounteren</code>) Register</h4>
<div class="paragraph">
<p>The counter-enable register <code>hcounteren</code> is a 32-bit register that
controls the availability of the hardware performance monitoring
counters to the guest virtual machine.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq9kk9rg0AQxe_5FMOeImVl_dOm9RoI7UEopZdSeljjGqWbVXYXkjb43btimmpEs4fQk_De783MzjhPWUa1lgqiitNCwPvxe4iyUmic0W3BvwDFN-BVsKKcJ3T9iaB1VfHNwA_rD2c2N4VAljucs2KTawgJ9ESaMokzAaLgR52zTOMtlRvTLSC_cBMeqEm5ZwpXpoIpBoHvzIwu6Q4bA1DgITOuqqgAH6KklKaVgkNdOz2K2FD-gxV1f6I8ApFme42pWOelBKQ0lRqNZ-9O0cVZkol0IndrM1hotQmrJzbQmOlNmWRgdt3H57i9V-cHMitsx-kXalBijbaXu4y6rvt3vMWgTGfNAy-c8IIx7-kFQU94jc-E5VsjDPZ76ULXg_ygs5H_aGgPXcf8AXHFiic=" alt="Hypervisor counter-enable register (`hcounteren`).">
</div>
<div class="title">Figure 13. Hypervisor counter-enable register (<code>hcounteren</code>).</div>
</div>
<div class="paragraph">
<p>When the CY, TM, IR, or HPM_n_ bit in the <code>hcounteren</code> register is
clear, attempts to read the <code>cycle</code>, <code>time</code>, <code>instret</code>, or
<code>hpmcounter</code> <em>n</em> register while V=1 will cause a virtual-instruction
exception if the same bit in <code>mcounteren</code> is 1. When one of these bits
is set, access to the corresponding register is permitted when V=1,
unless prevented for some other reason. In VU-mode, a counter is not
readable unless the applicable bits are set in both <code>hcounteren</code> and
<code>scounteren</code>.</p>
</div>
<div class="paragraph">
<p><code>hcounteren</code> must be implemented. However, any of the bits may be
read-only zero, indicating reads to the corresponding counter will cause
an exception when V=1. Hence, they are effectively <strong>WARL</strong> fields.</p>
</div>
</div>
<div class="sect3">
<h4 id="hypervisor-time-delta-htimedelta-register"><a class="anchor" href="#hypervisor-time-delta-htimedelta-register"></a>Hypervisor Time Delta (<code>htimedelta</code>) Register</h4>
<div class="paragraph">
<p>The <code>htimedelta</code> CSR is a 64-bit read/write register that contains the delta
between the value of the <code>time</code> CSR and the value returned in VS-mode or
VU-mode. That is, reading the <code>time</code> CSR in VS or VU mode returns the
sum of the contents of <code>htimedelta</code> and the actual value of <code>time</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Because overflow is ignored when summing <code>htimedelta</code> and <code>time</code>, large
values of <code>htimedelta</code> may be used to represent negative time offsets.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNplkMFugzAQRO_5ipVPQZElAigHPqC3fkHVwxLWwaqxkb0SaSL-PRsBamhOlmb8Zsbet2SQOSaoB4fWw9dy3msTPGuDvXW_oD4PcBzgA51r8PyjYHaTvREU1fSd7fYSBDGMuiN76RiqHDYithS18eCtW3RHhnWP8SJtZb5efsJvahOulPQgCRIGZZHtRI84ajFAnUolc9OAQhyhZrqyRn_uQgSVGCPL3CZEGZDgPk3ZK5s_0Y356nZse2rJMar1Q-Yn57D0Ff-IU_W3pdjWPgChoXSu" alt="Hypervisor time delta register.">
</div>
<div class="title">Figure 14. Hypervisor time delta register.</div>
</div>
<div class="paragraph">
<p>When XLEN=32, <code>htimedeltah</code> is a 32-bit read/write register
that aliases bits 63:32 of <code>htimedelta</code>.
Register <code>htimedeltah</code> does not exist when XLEN=64.</p>
</div>
<div class="paragraph">
<p>If the <code>time</code> CSR is implemented, <code>htimedelta</code> (and <code>htimedeltah</code> for XLEN=32)
must be implemented.</p>
</div>
</div>
<div class="sect3">
<h4 id="hypervisor-trap-value-htval-register"><a class="anchor" href="#hypervisor-trap-value-htval-register"></a>Hypervisor Trap Value (<code>htval</code>) Register</h4>
<div class="paragraph">
<p>The <code>htval</code> register is an HSXLEN-bit read/write register formatted as
shown in <a href="#htvalreg">Hypervisor trap value register (<code>htval</code>).</a>. When a trap is taken into
HS-mode, <code>htval</code> is written with additional exception-specific
information, alongside <code>stval</code>, to assist software in handling the trap.</p>
</div>
<div id="htvalreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNptkDFrwzAUhPf8ikNTTBHYTibvLR3aLlkKpcNzIsUiimSkR5I2-L_3hTg0pp0Ed7q7T5pvjCXmlNH0nlzAx3ieGxsDa0t757-gXh9Q9Xgi71ta7xSubnbfBvVy-CxmcylCikfdGbftGMsSE5E2JmkbEJwfdW8s6z2lrawtytvlS_iP2saTybqXBinDoi5moic6ajGgnlfvL49vulICnXuSXIWGzYk1hXUXE1RmSizQbUyCkXEehuK-obxEJ-a92_GBvLr9yPXNJcapevgP5helnq7-ALcodds=?id=htvalreg" alt="Hypervisor trap value register (`htval`).">
</div>
<div class="title">Figure 15. Hypervisor trap value register (<code>htval</code>).</div>
</div>
<div class="paragraph">
<p>When a guest-page-fault trap is taken into HS-mode, <code>htval</code> is written
with either zero or the guest physical address that faulted, shifted
right by 2 bits. For other traps, <code>htval</code> is set to zero, but a future
standard or extension may redefine <code>htval&#8217;s</code> setting for other traps.</p>
</div>
<div class="paragraph">
<p>A guest-page fault may arise due to an implicit memory access during
first-stage (VS-stage) address translation, in which case a guest
physical address written to <code>htval</code> is that of the implicit memory
access that faultedâ€”for example, the address of a VS-level page table
entry that could not be read. (The guest physical address corresponding
to the original virtual address is unknown when VS-stage translation
fails to complete.) Additional information is provided in CSR <code>htinst</code>
to disambiguate such situations.</p>
</div>
<div class="paragraph">
<p>Otherwise, for misaligned loads and stores that cause guest-page faults,
a nonzero guest physical address in <code>htval</code> corresponds to the faulting
portion of the access as indicated by the virtual address in <code>stval</code>.
For instruction guest-page faults on systems with variable-length
instructions, a nonzero <code>htval</code> corresponds to the faulting portion of
the instruction as indicated by the virtual address in <code>stval</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A guest physical address written to <code>htval</code> is shifted right by 2Â bits
to accommodate addresses wider than the current XLEN. For RV32, the
hypervisor extension permits guest physical addresses as wide as 34
bits, and <code>htval</code> reports bits 33:2 of the address. This shift-by-2
encoding of guest physical addresses matches the encoding of physical
addresses in PMP address registers (<a href="#pmp">[pmp]</a>) and in
page table entries (<a href="#sv32">[sv32]</a>, <a href="#sv39">[sv39]</a>, <a href="#sv48">[sv48]</a>, and <a href="#sv57">[sv57]</a>).</p>
</div>
<div class="paragraph">
<p>If the least-significant two bits of a faulting guest physical address
are needed, these bits are ordinarily the same as the least-significant
two bits of the faulting virtual address in <code>stval</code>. For faults due to
implicit memory accesses for VS-stage address translation, the
least-significant two bits are instead zeros. These cases can be
distinguished using the value provided in register <code>htinst</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>htval</code> is a <strong>WARL</strong> register that must be able to hold zero and may be capable
of holding only an arbitrary subset of other 2-bit-shifted guest
physical addresses, if any.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Unless it has reason to assume otherwise (such as a platform standard),
software that writes a value to <code>htval</code> should read back from <code>htval</code> to
confirm the stored value.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="hypervisor-trap-instruction-htinst-register"><a class="anchor" href="#hypervisor-trap-instruction-htinst-register"></a>Hypervisor Trap Instruction (<code>htinst</code>) Register</h4>
<div class="paragraph">
<p>The <code>htinst</code> register is an HSXLEN-bit read/write register formatted as
shown in <a href="#htinstreg">Hypervisor trap instruction (<code>htinst</code>) register.</a>. When a trap is taken into
HS-mode, <code>htinst</code> is written with a value that, if nonzero, provides
information about the instruction that trapped, to assist software in
handling the trap. The values that may be written to <code>htinst</code> on a trap
are documented in <a href="#tinst-vals">Transformed Instruction or Pseudoinstruction for <code>mtinst</code> or <code>htinst</code></a>.</p>
</div>
<div id="htinstreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNptkDFrwzAUhPf8ikNTTBHYTibvLR2SLl0KocNzIsWiimSkB0kT_N_7Qhwa006CO93dJ813xhJzymh6Ty5gM56XxsbA2tLB-W-o9ROqHi_kfUvbL4Wbm93ZoF4On8VsLkVI8ag74_YdY1liItLOJG0DgvOj7o1lfaC0l7VFeb98Df9R23gyWffSIGVY1MVM9ERHLQbU6_vH6vlNV0qgc0-Sq9CwObGmsO1igspMiQW6jUkwMi7DUDw2lNfoxHx0O3Yhs7p_ye3RJcateviP5pelns7-ADmqdlY=?id=htinstreg" alt="Hypervisor trap instruction (`htinst`) register.">
</div>
<div class="title">Figure 16. Hypervisor trap instruction (<code>htinst</code>) register.</div>
</div>
<div class="paragraph">
<p><code>htinst</code> is a <strong>WARL</strong> register that need only be able to hold the values that
the implementation may automatically write to it on a trap.</p>
</div>
</div>
<div class="sect3">
<h4 id="hgatp"><a class="anchor" href="#hgatp"></a>Hypervisor Guest Address Translation and Protection (<code>hgatp</code>) Register</h4>
<div class="paragraph">
<p>The <code>hgatp</code> register is an HSXLEN-bit read/write register, formatted as
shown in <a href="#rv32hgatp">Hypervisor guest address translation and protection register <code>hgatp</code> when HSXLEN=32.</a> for HSXLEN=32 and
<a href="#rv64hgatp">Hypervisor guest address translation and protection register <code>hgatp</code> when HSXLEN=64 for MODE values Bare, Sv39x4, Sv48x4, and Sv57x4.</a> for HSXLEN=64, which controls
G-stage address translation and protection, the second stage of
two-stage translation for guest virtual addresses (see
<a href="#two-stage-translation">Two-Stage Address Translation</a>). Similar to CSR <code>satp</code>, this
register holds the physical page number (PPN) of the guest-physical root
page table; a virtual machine identifier (VMID), which facilitates
address-translation fences on a per-virtual-machine basis; and the MODE
field, which selects the address-translation scheme for guest physical
addresses. When <code>mstatus</code>.TVM=1, attempts to read or write <code>hgatp</code> while
executing in HS-mode will raise an illegal-instruction exception.</p>
</div>
<div id="rv32hgatp" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrNVMFOg0AUvPcrXvYEMZsAxRS5mVQTE9HGgx6Mh6UsLXG7S5Y1VJv-u4stBVopmKjpifDezJu3w7BGRGOilMzATxlJODxvnys_FlzhmCwS9g4oOAM7hWvCWEimrwg23Sz5oOC46xdzYOhBIEWO5zSZzRW4FjSKJKISxxx4wrZ1RmOFF0TOtNrQKsEF-aAaiiXNcKon6GEwdMyBrkuSY90ANLSRXjdLiWaAHwqppTJYrddmA2XVUYouFSZ8OhcSUKaIVKid6lzsqO4elfLoGNFrJXZqOq3rdmhWbox-qFk55HVL1onB_fiqWrdtaMc5_CIQ5Tt-45IyomikSSL9rhwKpcTisNM8lFFIAjKeLh9uTVTGOt-EFIWCRfthNo9_strCX2H99Y3RY3Az7hu4kzOt89_6K9cmk7vW4BemnbBn3r96Vjet183p1H1tA436gGqXmn3ehH0CaMk0KQ==?id=rv32hgatp" alt="Hypervisor guest address translation and protection register `hgatp` when HSXLEN=32.">
</div>
<div class="title">Figure 17. Hypervisor guest address translation and protection register <code>hgatp</code> when HSXLEN=32.</div>
</div>
<div id="rv64hgatp" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrdVE1PwkAQvfMrJntqYzYp_UDszQRNTESJBz0QD1u6hcZlt9muKUr6312E1lYoAvH71OzMvHlvX2fWCGlElJIp-AkjMYfh6jv3I8EVjsg0Zk-A-kfQTuCcMBaQ0QOCZTaNnynYbn5vtgzdCKTI8ITG44kC14JakIRU4ogDj9kqzmik8JTIsWZzrKJ4AV6LBmJGU5zoDroZOLbZ0nFJMqwTgDoO0nLThHBwwVd0pjDho4mQgFJFpNJqAyE1fwrzPDdrUKsRSnm4BeidlEBnT06v2wj9gPP44Hu67oH3dN-89fbktBqRGyirwP5172xXuf5iioozfuSSMqJoqEEi2RQOhFJiup6pazcWlICMu9ObSxMVu5AtJxsFgoXvN8Dc_mcqgl8n_NMVV9x2_phjzg85dtu_6P2zMYOvd20wuNq617_YM-9bPau9oqVl3eb30i6LOs1F7Z1aVZ77tlUvewHVs7H3?id=rv64hgatp" alt="Hypervisor guest address translation and protection register `hgatp` when HSXLEN=64 for MODE values Bare, Sv39x4, Sv48x4, and Sv57x4.">
</div>
<div class="title">Figure 18. Hypervisor guest address translation and protection register <code>hgatp</code> when HSXLEN=64 for MODE values Bare, Sv39x4, Sv48x4, and Sv57x4.</div>
</div>
<div class="paragraph">
<p><a href="#hgatp-mode">Encoding of <code>hgatp</code> MODE field.</a> shows the encodings of the MODE field when
HSXLEN=32 and HSXLEN=64. When MODE=Bare, guest physical addresses are
equal to supervisor physical addresses, and there is no further memory
protection for a guest virtual machine beyond the physical memory
protection scheme described in <a href="#pmp">[pmp]</a>. In this
case, software must write zero to the remaining fields in <code>hgatp</code>.
Attempting to select MODE=Bare with a nonzero pattern in the remaining fields
has an UNSPECIFIED effect on the value that the remaining fields assume and an
UNSPECIFIED effect on G-stage address translation and protection behavior.</p>
</div>
<div class="paragraph">
<p>When HSXLEN=32, the only other valid setting for MODE is Sv32x4, which
is a modification of the usual Sv32 paged virtual-memory scheme,
extended to support 34-bit guest physical addresses. When HSXLEN=64,
modes Sv39x4, Sv48x4, and Sv57x4 are defined as modifications of the
Sv39, Sv48, and Sv57 paged virtual-memory schemes. All of these paged
virtual-memory schemes are described in
<a href="#guest-addr-translation">Guest Physical Address Translation</a>.</p>
</div>
<div class="paragraph">
<p>The remaining MODE settings when HSXLEN=64 are reserved for future use
and may define different interpretations of the other fields in <code>hgatp</code>.</p>
</div>
<table id="hgatp-mode" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 4. Encoding of <code>hgatp</code> MODE field.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="3">HSXLEN=32</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Value</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<br>
1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Bare<br>
Sv32x4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No translation or protection.<br>
Page-based 34-bit virtual addressing (2-bit extension of
Sv32).</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>HSXLEN=64</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Value</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<br>
1-7<br>
8<br>
9<br>
10<br>
11-15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Bare<br>
â€”<br>
Sv39x4<br>
Sv48x4<br>
Sv57x4<br>
â€”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No translation or protection.<br>
<em>Reserved</em><br>
Page-based 41-bit virtual addressing (2-bit extension of
Sv39).<br>
Page-based 50-bit virtual addressing (2-bit extension of
Sv48).<br>
Page-based 59-bit virtual addressing (2-bit extension of
Sv57).<br>
<em>Reserved</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Implementations are not required to support all defined MODE settings
when HSXLEN=64.</p>
</div>
<div class="paragraph">
<p>A write to <code>hgatp</code> with an unsupported MODE value is not ignored as it
is for <code>satp</code>. Instead, the fields of <code>hgatp</code> are <strong>WARL</strong> in the normal way,
when so indicated.</p>
</div>
<div class="paragraph">
<p>As explained in <a href="#guest-addr-translation">Guest Physical Address Translation</a>, for the
paged virtual-memory schemes (Sv32x4, Sv39x4, Sv48x4, and Sv57x4), the
root page table is 16 KiB and must be aligned to a 16-KiB boundary. In
these modes, the lowest two bits of the physical page number (PPN) in
<code>hgatp</code> always read as zeros. An implementation that supports only the
defined paged virtual-memory schemes and/or Bare may make PPN[1:0]
read-only zero.</p>
</div>
<div class="paragraph">
<p>The number of VMID bits is UNSPECIFIED and may be zero. The number of implemented
VMID bits, termed <em>VMIDLEN</em>, may be determined by writing one to every
bit position in the VMID field, then reading back the value in <code>hgatp</code>
to see which bit positions in the VMID field hold a one. The
least-significant bits of VMID are implemented first: that is, if
VMIDLEN &gt; 0, VMID[VMIDLEN-1:0] is writable. The maximal
value of VMIDLEN, termed VMIDMAX, is 7 for Sv32x4 or 14 for Sv39x4,
Sv48x4, and Sv57x4.</p>
</div>
<div class="paragraph">
<p>The <code>hgatp</code> register is considered <em>active</em> for the purposes of the
address-translation algorithm <em>unless</em> the effective privilege mode is U
and <code>hstatus</code>.HU=0.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This definition simplifies the implementation of speculative execution
of HLV, HLVX, and HSV instructions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that writing <code>hgatp</code> does not imply any ordering constraints
between page-table updates and subsequent G-stage address translations.
If the new virtual machineâ€™s guest physical page tables have been
modified, or if a VMID is reused, it may be necessary to execute an
HFENCE.GVMA instruction (see <a href="#hfence.vma">Hypervisor Memory-Management Fence Instructions</a>) before or
after writing <code>hgatp</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="vsstatus"><a class="anchor" href="#vsstatus"></a>Virtual Supervisor Status (<code>vsstatus</code>) Register</h4>
<div class="paragraph">
<p>The <code>vsstatus</code> register is a VSXLEN-bit read/write register that is
VS-modeâ€™s version of supervisor register <code>sstatus</code>, formatted as shown
in <a href="#vsstatusreg-rv32">Virtual supervisor status (<code>vsstatus</code>) register when VSXLEN=32.</a> when VSXLEN=32 and
<a href="#vsstatusreg">Virtual supervisor status (<code>vsstatus</code>) register when VSXLEN=64.</a> when VSXLEN=64. When V=1,
<code>vsstatus</code> substitutes for the usual <code>sstatus</code>, so instructions that
normally read or modify <code>sstatus</code> actually access <code>vsstatus</code> instead.</p>
</div>
<div id="vsstatusreg-rv32" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UlAw1FHIS8xNtVJQDw8I8lSv1cEqF-zpiiplTJy2AHR9CLlQJ5xS-I0MQJUygkuFBUcbWhnE4pLGNBUh54ZfawQ2aSLdG-qLS8o3Ioi8QHX1CcAp6RKCKmVGnJkuIJlYHYXk_Ly0zHSr6pzEvFSgEmAQZBQXJCanWhkaGJnU1gIAFTeeWw==?id=vsstatusreg-rv32" alt="Virtual supervisor status (`vsstatus`) register when VSXLEN=32.">
</div>
<div class="title">Figure 19. Virtual supervisor status (<code>vsstatus</code>) register when VSXLEN=32.</div>
</div>
<div id="vsstatusreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UlAw1FHIS8xNtVJQDw8I8lSv1cEqF-zpiiplTJy2AHR9CLlQJ5xS-I0MQJUygkuFBUcbWhnE4pLGNBUh54ZfawQ2aSLdG-qLS8o3Ioi8QHX1CcAp6RKCKmVOlP9DI3wwfWhkSZx7XEAysToKyfl5aZnpVtU5iXmpQCUmOgoZxQWJyalWhgZGJrW1AMn4rsc=?id=vsstatusreg" alt="Virtual supervisor status (`vsstatus`) register when VSXLEN=64.">
</div>
<div class="title">Figure 20. Virtual supervisor status (<code>vsstatus</code>) register when VSXLEN=64.</div>
</div>
<div class="paragraph">
<p>The UXL field controls the effective XLEN for VU-mode, which may differ
from the XLEN for VS-mode (VSXLEN). When VSXLEN=32, the UXL field does
not exist, and VU-mode XLEN=32. When VSXLEN=64, UXL is a <strong>WARL</strong> field that is
encoded the same as the MXL field of <code>misa</code>, shown in <a href="#misabase">[misabase]</a>. In particular, an implementation may make UXL be a read-only copy of field VSXL of <code>hstatus</code>, forcing VU-mode XLEN=VSXLEN.</p>
</div>
<div class="paragraph">
<p>If VSXLEN is changed from 32 to a wider width, and if field UXL is not
restricted to a single value, it gets the value corresponding to the
widest supported width not wider than the new VSXLEN.</p>
</div>
<div class="paragraph">
<p>When V=1, both <code>vsstatus</code>.FS and the HS-level <code>sstatus</code>.FS are in
effect. Attempts to execute a floating-point instruction when either
field is 0 (Off) raise an illegal-instruction exception. Modifying the
floating-point state when V=1 causes both fields to be set to 3 (Dirty).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For a hypervisor to benefit from the extension context status, it must
have its own copy in the HS-level <code>sstatus</code>, maintained independently of
a guest OS running in VS-mode. While a version of the extension context
status obviously must exist in <code>vsstatus</code> for VS-mode, a hypervisor
cannot rely on this version being maintained correctly, given that
VS-level software can change <code>vsstatus</code>.FS arbitrarily. If the HS-level
<code>sstatus</code>.FS were not independently active and maintained by the
hardware in parallel with <code>vsstatus</code>.FS while V=1, hypervisors would
always be forced to conservatively swap all floating-point state when
context-switching between virtual machines.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Similarly, when V=1, both <code>vsstatus</code>.VS and the HS-level <code>sstatus</code>.VS
are in effect. Attempts to execute a vector instruction when either
field is 0 (Off) raise an illegal-instruction exception. Modifying the
vector state when V=1 causes both fields to be set to 3 (Dirty).</p>
</div>
<div class="paragraph">
<p>Read-only fields SD and XS summarize the extension context status as it
is visible to VS-mode only. For example, the value of the HS-level
<code>sstatus</code>.FS does not affect <code>vsstatus</code>.SD.</p>
</div>
<div class="paragraph">
<p>An implementation may make field UBE be a read-only copy of
<code>hstatus</code>.VSBE.</p>
</div>
<div class="paragraph">
<p>When V=0, <code>vsstatus</code> does not directly affect the behavior of the
machine, unless a virtual-machine load/store (HLV, HLVX, or HSV) or the
MPRV feature in the <code>mstatus</code> register is used to execute a load or
store <em>as though</em> V=1.</p>
</div>
<div class="paragraph">
<p>The Zicfilp extension adds the <code>SPELP</code> field that holds the previous <code>ELP</code>, and
is updated as specified in <a href="#ZICFILP_FORWARD_TRAPS">[ZICFILP_FORWARD_TRAPS]</a>. The <code>SPELP</code> field is
encoded as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>0 - <code>NO_LP_EXPECTED</code> - no landing pad instruction expected.</p>
</li>
<li>
<p>1 - <code>LP_EXPECTED</code> - a landing pad instruction is expected.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Ssdbltrp adds an S-mode-disable-trap (<code>SDT</code>) field extension to address
double trap (See <a href="#supv-double-trap">[supv-double-trap]</a>) in VS-mode.</p>
</div>
</div>
<div class="sect3">
<h4 id="virtual-supervisor-interrupt-vsip-and-vsie-registers"><a class="anchor" href="#virtual-supervisor-interrupt-vsip-and-vsie-registers"></a>Virtual Supervisor Interrupt (<code>vsip</code> and <code>vsie</code>) Registers</h4>
<div class="paragraph">
<p>The <code>vsip</code> and <code>vsie</code> registers are VSXLEN-bit read/write registers that
are VS-modeâ€™s versions of supervisor CSRs <code>sip</code> and <code>sie</code>, formatted as
shown in <a href="#vsipreg">Virtual supervisor interrupt-pending register (<code>vsip</code>).</a> and <a href="#vsiereg">Virtual supervisor interrupt-enable register (<code>vsie</code>).</a>
respectively. When V=1, <code>vsip</code> and <code>vsie</code> substitute for the usual <code>sip</code>
and <code>sie</code>, so instructions that normally read or modify <code>sip</code>/<code>sie</code>
actually access <code>vsip</code>/<code>vsie</code> instead. However, interrupts directed to
HS-level continue to be indicated in the HS-level <code>sip</code> register, not in
<code>vsip</code>, when V=1.</p>
</div>
<div id="vsipreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqtUU1Lw0AQvfdXDHtKkIV8FA-5eVAoVA8KKoiHSbNpQje7y-6UVEv-uxvbSNMo9OBp2Tfz3ryZFxSiRCLrIDMSawVvx3eflVoRL7Gp5Qew-yuIDdyhlDmuNgwOVVd_Ckjm3Xs4C7wQWN3yStTrimAewQjEQlheKlC1POJSlMQbtGs_LY2G5p48QXO9E44br-DFIE3CmcctttwXgD0_vS5vH3jMvGlnUEF8DRmJHXFUq0pbYI7Qkjeda-ttONh3XXiqEP1NFao4J54yF4qEtVtD7mKJrF98-POtskIiicKTtPkNzjWRbqaV8Q5BPxJY8HLzuAzZEF97CIPlWhbnoYWXnyv7juWfPE-j-zldmoxP_QWzKuCw?id=vsipreg" alt="Virtual supervisor interrupt-pending register (`vsip`).">
</div>
<div class="title">Figure 21. Virtual supervisor interrupt-pending register (<code>vsip</code>).</div>
</div>
<div id="vsiereg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqtUU1Lw0AQvfdXDHtKkIV8FA-5eVAoVA8KKoiHSbNpQje7y-6UVEv-uxvbSNMo9OBp2Tfz3ryZFxSiRCLrIDMSawVvx3eflVoRL7Gp5Qew-yuIDdyhlDmuNgwOVVd_Ckjm3Xs4C7wQWN3yStTrimAewQjEQlheKlC1POJSlMQbtGs_LY2G5p48QXO9E44br-DFIE3CmcctttwXgD0_vS5vH3jMvGlnUEF8DRmJHXFUq0pbYI7Qkjeda-ttONh3XXiqEP1NFao4J54yF4qEtVtD7mKJrF98-POtskIiicKTtPkNzjWRbqaV8Q5BPxJY8HLzuAzZEF97CIPlWhbnoYWXnyv7juWfPE-j-zldmoxP_QWzKuCw?id=vsiereg" alt="Virtual supervisor interrupt-enable register (`vsie`).">
</div>
<div class="title">Figure 22. Virtual supervisor interrupt-enable register (<code>vsie</code>).</div>
</div>
<div class="paragraph">
<p>The standard portions (bits 15:0) of registers <code>vsip</code> and <code>vsie</code> are
formatted as shown in <a href="#vsipreg-standard">Standard portion (bits 15:0) of <code>vsip</code>.</a>
and <a href="#vsiereg-standard">Standard portion (bits 15:0) of <code>vsie</code>.</a> respectively.</p>
</div>
<div id="vsipreg-standard" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrNk1FLwzAUhd_3Ky55apFAm3RT-yoOBEVhvokP6ZquxS4tSWDT0f9uald0m41tYeBT4d7znXNIEyfmCdNaKgjLnGUCXvbfXZgUQuOErbP8HdDDBfglzFmeR2z5hqDZquyDAwmqV3fiGCOQxQanPFulGgIPDoYs5hInAkSW7-c5TzReM7kyadRrxTV8Mo2KLVe4NA7GDChxJ2Yu2QabRe1o2qqSCZhBGBXSJCnYVZX7Q4T8KTIqzbcaM7FMCwlIaSY1siDBCcJFbAMoapsQi4oMb-INbHLdp8hVLepYNofaRc4sJJr2yQ5GZxNbtt8n2_sz-8vh8shh8JXzvsscLJz6RwK6v3mc3z2h9qU1b8mr3N-hTje0uG1c7BA9gp7HQAsbdK5jJL0eVR8RPYMT_TdO_qhr_QnuA-_y?id=vsipreg-standard" alt="Standard portion (bits 15:0) of `vsip`.">
</div>
<div class="title">Figure 23. Standard portion (bits 15:0) of <code>vsip</code>.</div>
</div>
<div id="vsiereg-standard" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrNk8FrgzAYxe_9Kz5yUkYgGtttXkcLg40dutvYIdZYZWmUGGi34v--OCtb25mpUNhJ-L73e-8REyfmCdNalRAWgmUSXg7ffZjkUuOEbTLxDujxCrwCFkyIiK3eEDTbMvvg4AfVqztxjBGofItTnq1TDQGBoyGLucKJBJmJw1zwROMNU2uTRkkrruGzaZTveIkL42DMgPruxMwV22KzqB1N27JgEmYQRrkySSXsq8r9IULeFBmV5juNmVyluQJUaqY0siDBGcJlbAMoapv4FpU_vAkZ2OS2T5GbWtSxbA61i5xZSDTtkx2MzvZt2V6fbPJn9pfD9YnD4CtHvsscLZz6RwJ6uHta3M9R-9Kat0Qq93eo0w0t542LHaIn0PMYaGmDLnWMfq9H1UdEL-BE_42TN-pafwKPsu_G?id=vsiereg-standard" alt="Standard portion (bits 15:0) of `vsie`.">
</div>
<div class="title">Figure 24. Standard portion (bits 15:0) of <code>vsie</code>.</div>
</div>
<div class="paragraph">
<p>Extension Shlcofideleg supports delegating LCOFI interrupts to VS-mode.
If the Shlcofideleg extension is implemented, <code>hideleg</code> bit 13 is
writable; otherwise, it is read-only zero.
When bit 13 of <code>hideleg</code> is zero, <code>vsip</code>.LCOFIP and <code>vsie</code>.LCOFIE
are read-only zeros.
Else, <code>vsip</code>.LCOFIP and <code>vsie</code>.LCOFIE are aliases of <code>sip</code>.LCOFIP
and <code>sie</code>.LCOFIE.</p>
</div>
<div class="paragraph">
<p>When bit 10 of <code>hideleg</code> is zero, <code>vsip</code>.SEIP and <code>vsie</code>.SEIE are
read-only zeros. Else, <code>vsip</code>.SEIP and <code>vsie</code>.SEIE are aliases of
<code>hip</code>.VSEIP and <code>hie</code>.VSEIE.</p>
</div>
<div class="paragraph">
<p>When bit 6 of <code>hideleg</code> is zero, <code>vsip</code>.STIP and <code>vsie</code>.STIE are
read-only zeros. Else, <code>vsip</code>.STIP and <code>vsie</code>.STIE are aliases of
<code>hip</code>.VSTIP and <code>hie</code>.VSTIE.</p>
</div>
<div class="paragraph">
<p>When bit 2 of <code>hideleg</code> is zero, <code>vsip</code>.SSIP and <code>vsie</code>.SSIE are
read-only zeros. Else, <code>vsip</code>.SSIP and <code>vsie</code>.SSIE are aliases of
<code>hip</code>.VSSIP and <code>hie</code>.VSSIE.</p>
</div>
</div>
<div class="sect3">
<h4 id="virtual-supervisor-trap-vector-base-address-vstvec-register"><a class="anchor" href="#virtual-supervisor-trap-vector-base-address-vstvec-register"></a>Virtual Supervisor Trap Vector Base Address (<code>vstvec</code>) Register</h4>
<div class="paragraph">
<p>The <code>vstvec</code> register is a VSXLEN-bit read/write register that is
VS-modeâ€™s version of supervisor register <code>stvec</code>, formatted as shown in
<a href="#vstvecreg">Virtual supervisor trap vector base address register <code>vstvec</code>.</a>. When V=1, <code>vstvec</code> substitutes for
the usual <code>stvec</code>, so instructions that normally read or modify <code>stvec</code>
actually access <code>vstvec</code> instead. When V=0, <code>vstvec</code> does not directly
affect the behavior of the machine.</p>
</div>
<div id="vstvecreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrNU7FuwjAQ3fmKk6dElaXEIAZvVE0naKUitZUQg0McEtWxI8dVaFH-vU4hgkBow1J1svzO7967850T8ZgZowuguWCphMX-3NJYSYNjlqXiA9DsBvwc7pkQIVu9IdhFi_STAxlVS3fg2ESgVYkTnq4TAyMPWiCLuMaxBJmKPS54bHDG9NqqDb3mcU0-Q0O14QXObQabDIbEHVhcsxLbAKDn-es0eMA-sqaLnEnwPaCGbwxmcpUoDagwTBtrOlTa2ihgW1XucQZymcpl9APxoDm-UtK7yOxQPCbeTubBoimZkmVv67RueHPH71JzwQyPLEnlXXCojFHZeaRdiFNLAnJeJk9TFzVjU-6GAIVKRKfD4vb_pmutAf2en988o9njXdC3__-ubeM_7VrHoh22hXi9doq0X30Ba29-5w==?id=vstvecreg" alt="Virtual supervisor trap vector base address register `vstvec`.">
</div>
<div class="title">Figure 25. Virtual supervisor trap vector base address register <code>vstvec</code>.</div>
</div>
</div>
<div class="sect3">
<h4 id="virtual-supervisor-scratch-vsscratch-register"><a class="anchor" href="#virtual-supervisor-scratch-vsscratch-register"></a>Virtual Supervisor Scratch (<code>vsscratch</code>) Register</h4>
<div class="paragraph">
<p>The <code>vsscratch</code> register is a VSXLEN-bit read/write register that is
VS-modeâ€™s version of supervisor register <code>sscratch</code>, formatted as shown
in <a href="#vsscratchreg">Virtual supervisor scratch register <code>vsscratch</code>.</a>. When V=1, <code>vsscratch</code>
substitutes for the usual <code>sscratch</code>, so instructions that normally read
or modify <code>sscratch</code> actually access <code>vsscratch</code> instead. The contents
of <code>vsscratch</code> never directly affect the behavior of the machine.</p>
</div>
<div id="vsscratchreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNp9jk1rwkAQhu_-imFPhrKQD-kh93pqexFKQTxMkl2zdN0Ns4PaSv57p2iLQexp4P145p13xiIzJagHjy7A-nJPtY2BtcWd85-gXh6gGGCJ3jfYfig4u8l9GSgX4yabzQUEFA-6N27bMyxymIjYGdI2QHD-ontjWe-QtvKtyn_DP-UbtYlHk_QgBIFBVWYz0QkPWgxQb6v356dXXSgZnQYMUDxCzebIGkPbRwKVGIlldBNJZiQ4jWN2TcjvV03o_inuU2oJue3_AFU5TZzHXdlT2DeCsHwS?id=vsscratchreg" alt="Virtual supervisor scratch register `vsscratch`.">
</div>
<div class="title">Figure 26. Virtual supervisor scratch register <code>vsscratch</code>.</div>
</div>
</div>
<div class="sect3">
<h4 id="virtual-supervisor-exception-program-counter-vsepc-register"><a class="anchor" href="#virtual-supervisor-exception-program-counter-vsepc-register"></a>Virtual Supervisor Exception Program Counter (<code>vsepc</code>) Register</h4>
<div class="paragraph">
<p>The <code>vsepc</code> register is a VSXLEN-bit read/write register that is
VS-modeâ€™s version of supervisor register <code>sepc</code>, formatted as shown in
<a href="#vsepcreg">Virtual supervisor exception program counter (<code>vsepc</code>).</a>. When V=1, <code>vsepc</code> substitutes for the
usual <code>sepc</code>, so instructions that normally read or modify <code>sepc</code>
actually access <code>vsepc</code> instead. When V=0, <code>vsepc</code> does not directly
affect the behavior of the machine.</p>
</div>
<div class="paragraph">
<p><code>vsepc</code> is a <strong>WARL</strong> register that must be able to hold the same set of values
that <code>sepc</code> can hold.</p>
</div>
<div id="vsepcreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNp9jk1LAzEQhu_9FUNOXSSwH8XD3u1JvRREEA-zu5NuME1CMrTVsv_dkVbpInoKPO-8T97lQAaZU4Y2OrQeXi7vqTXBsza4s-4d1MMNVBHW6FyH_ZuCc5rtB0G9ml6LxVJEkMJBj2S3I8OqhBnEgZI2Hrx1F-7IsN5h2spvTfl9_FX-RbtwpKyjGEQGTV0shCc8aAlAPW2e7-8edaVkdI7oobqFlunIGn0_hgQqMyaW0V1IMiPDaZqKa0P5d5X88E9xnyn2P-WmnqfnYVfxXPQJfCl6Yg==?id=vsepcreg" alt="Virtual supervisor exception program counter (`vsepc`).">
</div>
<div class="title">Figure 27. Virtual supervisor exception program counter (<code>vsepc</code>).</div>
</div>
</div>
<div class="sect3">
<h4 id="virtual-supervisor-cause-vscause-register"><a class="anchor" href="#virtual-supervisor-cause-vscause-register"></a>Virtual Supervisor Cause (<code>vscause</code>) Register</h4>
<div class="paragraph">
<p>The <code>vscause</code> register is a VSXLEN-bit read/write register that is
VS-modeâ€™s version of supervisor register <code>scause</code>, formatted as shown in
<a href="#vscausereg">Virtual supervisor cause register (<code>vscause</code>).</a>. When V=1, <code>vscause</code> substitutes
for the usual <code>scause</code>, so instructions that normally read or modify
<code>scause</code> actually access <code>vscause</code> instead. When V=0, <code>vscause</code> does not
directly affect the behavior of the machine.</p>
</div>
<div class="paragraph">
<p><code>vscause</code> is a <strong>WLRL</strong> register that must be able to hold the same set of
values that <code>scause</code> can hold.</p>
</div>
<div id="vscausereg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqVkUFLw0AQhe_9FcOeEmQhSXOQXKWCED0oqCAeNs2kCW52l82UREv-uxvbWGKttqeQN9-8eezzciwEkW0gMVJUCl52301SaEW8EHUl34HdXkBo4FpImYnlG4PttKk-EKK4f_VnnjMCq1teYrUqCeIAJqLI0fJCgarkTpdYEK-FXblr82CEh-UDNdMdNtw4B2cG88ifOd2KlrsBsMeH53Rxx0PmQjdGKIghybR1BxvY9L3_Cxt9s6GDCTviQi1LbYE1JCyx4w7B8VVU-R-LN4rQ2rWhfc4psOiWaKjSCq50jiefSUib8ZevlUUpCPNBIdL14WQayxusgXlP6X3qs7H2dlsiy7TMf5btn_5050aD5Kv__zKzc6res9HlFP4EdQH98g==?id=vscausereg" alt="Virtual supervisor cause register (`vscause`).">
</div>
<div class="title">Figure 28. Virtual supervisor cause register (<code>vscause</code>).</div>
</div>
</div>
<div class="sect3">
<h4 id="virtual-supervisor-trap-value-vstval-register"><a class="anchor" href="#virtual-supervisor-trap-value-vstval-register"></a>Virtual Supervisor Trap Value (<code>vstval</code>) Register</h4>
<div class="paragraph">
<p>The <code>vstval</code> register is a VSXLEN-bit read/write register that is
VS-modeâ€™s version of supervisor register <code>stval</code>, formatted as shown in
<a href="#vstvalreg">Virtual supervisor trap value register (<code>vstval</code>).</a>. When V=1, <code>vstval</code> substitutes for
the usual <code>stval</code>, so instructions that normally read or modify <code>stval</code>
actually access <code>vstval</code> instead. When V=0, <code>vstval</code> does not directly
affect the behavior of the machine.</p>
</div>
<div class="paragraph">
<p><code>vstval</code> is a <strong>WARL</strong> register that must be able to hold the same set of values
that <code>stval</code> can hold.</p>
</div>
<div id="vstvalreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNp9jk1LAzEURff9FZesOkhgPoqL2etK3QgiiIs3naQTTJMhebTVMv_dJ63SQXQVOPfdk7vsjSXmlNGOnlzAy_k9tjYG1pa2zr9D3V-hGnFL3ne0flM4pdl9GNSr6bVYLEWEFPd6MG4zMFYlZpB6k7QNCM6fuTeW9ZbSRn5ryu_jr_Iv2sWDyXoUg8jQ1MVCeKK9lgDq6fH57uZBV0pG55ECqmu0bA6sKayHmKAyU2IZ3cUkMzKO01RcGsq_qyb0_xR3mXfkf9pNPY9Pyy7iuekTAZV64Q==?id=vstvalreg" alt="Virtual supervisor trap value register (`vstval`).">
</div>
<div class="title">Figure 29. Virtual supervisor trap value register (<code>vstval</code>).</div>
</div>
</div>
<div class="sect3">
<h4 id="virtual-supervisor-address-translation-and-protection-vsatp-register"><a class="anchor" href="#virtual-supervisor-address-translation-and-protection-vsatp-register"></a>Virtual Supervisor Address Translation and Protection (<code>vsatp</code>) Register</h4>
<div class="paragraph">
<p>The <code>vsatp</code> register is a VSXLEN-bit read/write register that is
VS-modeâ€™s version of supervisor register <code>satp</code>, formatted as shown in
<a href="#rv32vsatpreg">Virtual supervisor address translation and protection <code>vsatp</code> register when VSXLEN=32.</a> for VSXLEN=32 and <a href="#rv64vsatpreg">Virtual supervisor address translation and protection <code>vsatp</code> register when VSXLEN=64.</a> for VSXLEN=64. When V=1,
<code>vsatp</code> substitutes for the usual <code>satp</code>, so instructions that normally
read or modify <code>satp</code> actually access <code>vsatp</code> instead. <code>vsatp</code> controls
VS-stage address translation, the first stage of two-stage translation
for guest virtual addresses (see
<a href="#two-stage-translation">Two-Stage Address Translation</a>).</p>
</div>
<div id="rv32vsatpreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrtVE1LxDAQve-vGHJqkUC_kLW3BREEVxY9eBAP6TbdFtOkpCNdXfrfTd2ttO5W24t48BTyZt68x8sQK-YJQ9QlhIVgmYTHw7kLEyWRJizPxCuQ5Rm4BVwxISK2fiawr5bZGwcvqJ_smWUGgVYVTXm2SRECB3ogi7mmiQSZiQMueII0Z3pj1HynbW7IR2iktrykhZlghoHv2TODa1ZRUwDiu8TYLQsmYQ5hpLSRKmFX13avy_nsCiBEvkXK5DpVGkiJTCMZpnreIJXL-Dtiz9kkTWeQeUKyS1yqmI-1G6Iq2it9kZoLhjxuEESVn6o0j3aM971bjSQQ62Fxd2OTdpOq_V6QSIn46_7Yo19muuOPjfrJMlncX1_-pzY1tdXqduya_rnQ5r8aWje1Ud_VxZimzsfknvfb3gHrrPu2?id=rv32vsatpreg" alt="Virtual supervisor address translation and protection `vsatp` register when VSXLEN=32.">
</div>
<div class="title">Figure 30. Virtual supervisor address translation and protection <code>vsatp</code> register when VSXLEN=32.</div>
</div>
<div id="rv64vsatpreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrtVEFPwjAUvvMrXnraYpoMqAR3IzEmJmKIHjwYDx3tYLG0S_vMULL_bicQNwEdHIwHT8u-9773fX371kDIlCNaB3GueKbhcfNcxanRSFO-yNQrkPEZdHO44kolfPpMYF112ZuEHiufwk7gB4E1BZ3LbDZHYBE0QC6kpakGnakNrmSKdMHtzKv1o21zRd5BE7OUjuZ-gh8G_V7Y8bjlBfUFIIM-8XZdzjUwiFEukXI9nRsLxCG36N0mxnp9B6uyDBvU6CBVavEN8fziZE3GTtRkn-ccHqkZHWTukawTx0bItnZjNPn2lb5oKxVHKSoE0Sz2VaoI7OJN70ElCSR4GN3dhGSby2KdMpIYJb6mMWz9ZY53_JHPnyyT0f315f_Wjt3aZHLbNqZ_bmnDX11a41ao7-zQ_98dtOmq3UzdQbPtHUh9Fc0=?id=rv64vsatpreg" alt="Virtual supervisor address translation and protection `vsatp` register when VSXLEN=64.">
</div>
<div class="title">Figure 31. Virtual supervisor address translation and protection <code>vsatp</code> register when VSXLEN=64.</div>
</div>
<div class="paragraph">
<p>The <code>vsatp</code> register is considered <em>active</em> for the purposes of the
address-translation algorithm <em>unless</em> the effective privilege mode is U
and <code>hstatus</code>.HU=0. However, even when <code>vsatp</code> is active, VS-stage
page-table entriesâ€™ A bits must not be set as a result of speculative
execution, unless the effective privilege mode is VS or VU.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In particular, virtual-machine load/store (HLV, HLVX, or HSV)
instructions that are mispredicted must not cause VS-stage
A bits to be set.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When V=0, a write to <code>vsatp</code> with an unsupported MODE value is either
ignored as it is for <code>satp</code>, or the fields of <code>vsatp</code> are treated as <strong>WARL</strong> in
the normal way. However, when V=1, a write to <code>satp</code> with an unsupported
MODE value <em>is</em> ignored and no write to <code>vsatp</code> is effected.</p>
</div>
<div class="paragraph">
<p>When V=0, <code>vsatp</code> does not directly affect the behavior of the machine,
unless a virtual-machine load/store (HLV, HLVX, or HSV) or the MPRV
feature in the <code>mstatus</code> register is used to execute a load or store <em>as
though</em> V=1.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hypervisor-instructions"><a class="anchor" href="#hypervisor-instructions"></a>Hypervisor Instructions</h3>
<div class="paragraph">
<p>The hypervisor extension adds virtual-machine load and store
instructions and two privileged fence instructions.</p>
</div>
<div class="sect3">
<h4 id="hypervisor-virtual-machine-load-and-store-instructions"><a class="anchor" href="#hypervisor-virtual-machine-load-and-store-instructions"></a>Hypervisor Virtual-Machine Load and Store Instructions</h4>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNp1kc8LgjAcxe_9FbvtMqwUGXgPDAoi0wrxYNssD2lsiw7i_94mzNzC03v78XlvfNdxdo9AvgCgu9VSRAAj0JRPFgHYvkhLGUSglJKrOxBDBJNrctrs1ea_K3r0iwnHGE4nEaGKoExIjRld2WQwktW7ITKY0MrDw3GbDa2OmWsXa6e-pJRrzNJZ2nfoPC00FO-yi1bBic1i-_XYGZ_ivE9N5cOEeHG6PKfDKjFHOrBAgLRNVavPMXPx-_4LFKB5Bw==" alt="svg">
</div>
</div>
<div class="paragraph">
<p>The hypervisor virtual-machine load and store instructions are valid
only in M-mode or HS-mode, or in U-mode when <code>hstatus</code>.HU=1. Each
instruction performs an explicit memory access with an effective privilege mode
of VS or VU. The effective privilege mode of the explicit memory access is VU
when <code>hstatus</code>.SPVP=0, and VS when <code>hstatus</code>.SPVP=1. As usual for VS-mode and
VU-mode, two-stage address translation is applied, and
the HS-level <code>sstatus</code>.SUM is ignored. HS-level <code>sstatus</code>.MXR makes
execute-only pages readable by explicit loads for both stages of address translation
(VS-stage and G-stage), whereas <code>vsstatus</code>.MXR affects only the first
translation stage (VS-stage).</p>
</div>
<div class="paragraph">
<p>For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
and LD, there is a corresponding virtual-machine load instruction:
HLV.B, HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I
or RV64I store instruction, SB, SH, SW, and SD, there is a corresponding
virtual-machine store instruction: HSV.B, HSV.H, HSV.W, and HSV.D.
Instructions HLV.WU, HLV.D, and HSV.D are not valid for RV32, of course.</p>
</div>
<div class="paragraph">
<p>Instructions HLVX.HU and HLVX.WU are the same as HLV.HU and HLV.WU,
except that <em>execute</em> permission takes the place of <em>read</em> permission
during address translation. That is, the memory being read must be
executable in both stages of address translation, but read permission is
not required. For the supervisor physical address that results from
address translation, the supervisor physical memory attributes must
grant both <em>execute</em> and <em>read</em> permissions. (The <em>supervisor physical
memory attributes</em> are the machineâ€™s physical memory attributes as
modified by physical memory protection, <a href="#pmp">[pmp]</a>, for
supervisor level.)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>HLVX cannot override machine-level physical memory protection (PMP), so
attempting to read memory that PMP designates as execute-only still
results in an access-fault exception.</p>
</div>
<div class="paragraph">
<p>Although HLVX instructionsâ€™ explicit memory accesses require execute
permissions, they still raise the same exceptions as other load
instructions, rather than raising fetch exceptions instead.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>HLVX.WU is valid for RV32, even though LWU and HLV.WU are not. (For
RV32, HLVX.WU can be considered a variant of HLV.W, as sign extension is
irrelevant for 32-bit values.)</p>
</div>
<div class="paragraph">
<p>Attempts to execute a virtual-machine load/store instruction (HLV, HLVX,
or HSV) when V=1 cause a virtual-instruction exception. Attempts to execute
one of these same instructions from U-mode when <code>hstatus</code>.HU=0 cause an
illegal-instruction exception.</p>
</div>
</div>
<div class="sect3">
<h4 id="hfence.vma"><a class="anchor" href="#hfence.vma"></a>Hypervisor Memory-Management Fence Instructions</h4>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDXUchLzE21UlDPL0jOT0lV11FILCkpAqpRNwey1YMjg0NcfZFYsbU6CN2mcN1FKUg6TdV11A1AegxQlRvDlaeV5iWXGCNpAbLVA4I8w0C6wDQue4oN0SwqS0xJKQJpSwczcOozQtOXWJwJcrN6WS6QRtFljupMc9QwUfdwc_VzdtULC_N1BOmHct1BXJAxsToKyfl5aZnAcIZ526i2FgDI1Gn-" alt="svg">
</div>
</div>
<div class="paragraph">
<p>The hypervisor memory-management fence instructions, HFENCE.VVMA and
HFENCE.GVMA, perform a function similar to SFENCE.VMA
(<a href="#sfence.vma">[sfence.vma]</a>), except applying to the
VS-level memory-management data structures controlled by CSR <code>vsatp</code>
(HFENCE.VVMA) or the guest-physical memory-management data structures
controlled by CSR <code>hgatp</code> (HFENCE.GVMA). Instruction SFENCE.VMA applies
only to the memory-management data structures controlled by the current
<code>satp</code> (either the HS-level <code>satp</code> when V=0 or <code>vsatp</code> when V=1).</p>
</div>
<div class="paragraph">
<p>HFENCE.VVMA is valid only in M-mode or HS-mode. Its effect is much the
same as temporarily entering VS-mode and executing SFENCE.VMA. Executing
an HFENCE.VVMA guarantees that any previous stores already visible to
the current hart are ordered before all implicit reads by that hart done
for VS-stage address translation for instructions that</p>
</div>
<div class="ulist">
<ul>
<li>
<p>are subsequent to the HFENCE.VVMA, and</p>
</li>
<li>
<p>execute when <code>hgatp</code>.VMID has the same setting as it did when
HFENCE.VVMA executed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Implicit reads need not be ordered when <code>hgatp</code>.VMID is different than
at the time HFENCE.VVMA executed. If operand <em>rs1</em>â‰ <code>x0</code>, it specifies a single guest virtual address, and if operand <em>rs2</em>â‰ <code>x0</code>, it specifies a single guest address-space identifier (ASID).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>An HFENCE.VVMA instruction applies only to a single virtual machine,
identified by the setting of <code>hgatp</code>.VMID when HFENCE.VVMA executes.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When <em>rs2</em>â‰ <code>x0</code>, bits XLEN-1:ASIDMAX of the value held
in <em>rs2</em> are reserved for future standard use. Until their use is
defined by a standard extension, they should be zeroed by software and
ignored by current implementations. Furthermore, if
ASIDLEN &lt; ASIDMAX, the implementation shall ignore bits
ASIDMAX-1:ASIDLEN of the value held in <em>rs2</em>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Simpler implementations of HFENCE.VVMA can ignore the guest virtual
address in <em>rs1</em> and the guest ASID value in <em>rs2</em>, as well as
<code>hgatp</code>.VMID, and always perform a global fence for the VS-level memory
management of all virtual machines, or even a global fence for all
memory-management data structures.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Neither <code>mstatus</code>.TVM nor <code>hstatus</code>.VTVM causes HFENCE.VVMA to trap.</p>
</div>
<div class="paragraph">
<p>HFENCE.GVMA is valid only in HS-mode when <code>mstatus</code>.TVM=0, or in M-mode
(irrespective of <code>mstatus</code>.TVM). Executing an HFENCE.GVMA instruction
guarantees that any previous stores already visible to the current hart
are ordered before all implicit reads by that hart done for G-stage
address translation for instructions that follow the HFENCE.GVMA. If
operand <em>rs1</em>â‰ <code>x0</code>, it specifies a single guest
physical address, shifted right by 2 bits, and if operand
<em>rs2</em>â‰ <code>x0</code>, it specifies a single virtual machine
identifier (VMID).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Conceptually, an implementation might contain two address-translation
caches: one that maps guest virtual addresses to guest physical
addresses, and another that maps guest physical addresses to supervisor
physical addresses. HFENCE.GVMA need not flush the former cache, but it
must flush entries from the latter cache that match the HFENCE.GVMAâ€™s
address and VMID arguments.</p>
</div>
<div class="paragraph">
<p>More commonly, implementations contain address-translation caches that
map guest virtual addresses directly to supervisor physical addresses,
removing a level of indirection. For such implementations, any entry
whose guest virtual address maps to a guest physical address that
matches the HFENCE.GVMAâ€™s address and VMID arguments must be flushed.
Selectively flushing entries in this fashion requires tagging them with
the guest physical address, which is costly, and so a common technique
is to flush all entries that match the HFENCE.GVMAâ€™s VMID argument,
regardless of the address argument.</p>
</div>
<hr>
<div class="paragraph">
<p>Like for a guest physical address written to <code>htval</code> on a trap, a guest
physical address specified in <em>rs1</em> is shifted right by 2Â bits to
accommodate addresses wider than the current XLEN.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When <em>rs2</em>â‰ <code>x0</code>, bits XLEN-1:VMIDMAX of the value held
in <em>rs2</em> are reserved for future standard use. Until their use is
defined by a standard extension, they should be zeroed by software and
ignored by current implementations. Furthermore, if
VMIDLEN &lt; VMIDMAX, the implementation shall ignore bits
VMIDMAX-1:VMIDLEN of the value held in <em>rs2</em>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Simpler implementations of HFENCE.GVMA can ignore the guest physical
address in <em>rs1</em> and the VMID value in <em>rs2</em> and always perform a global
fence for the guest-physical memory management of all virtual machines,
or even a global fence for all memory-management data structures.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code>hgatp</code>.MODE is changed for a given VMID, an HFENCE.GVMA with
<em>rs1</em>=<code>x0</code> (and <em>rs2</em> set to either <code>x0</code> or the VMID) must be executed
to order subsequent guest translations with the MODE changeâ€”even if the
old MODE or new MODE is Bare.</p>
</div>
<div class="paragraph">
<p>Attempts to execute HFENCE.VVMA or HFENCE.GVMA when V=1 cause a
virtual-instruction exception, while attempts to do the same in U-mode cause an
illegal-instruction exception. Attempting to execute HFENCE.GVMA in HS-mode
when <code>mstatus</code>.TVM=1 also causes an illegal-instruction exception.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="machine-level-csrs"><a class="anchor" href="#machine-level-csrs"></a>Machine-Level CSRs</h3>
<div class="paragraph">
<p>The hypervisor extension augments or modifies machine CSRs <code>mstatus</code>,
<code>mstatush</code>, <code>mideleg</code>, <code>mip</code>, and <code>mie</code>, and adds CSRs <code>mtval2</code> and
<code>mtinst</code>.</p>
</div>
<div class="sect3">
<h4 id="machine-status-mstatus-and-mstatush-registers"><a class="anchor" href="#machine-status-mstatus-and-mstatush-registers"></a>Machine Status (<code>mstatus</code> and <code>mstatush</code>) Registers</h4>
<div class="paragraph">
<p>The hypervisor extension adds two fields, MPV and GVA, to the
machine-level <code>mstatus</code> or <code>mstatush</code> CSR, and modifies the behavior of
several existing <code>mstatus</code> fields.
<a href="#hypervisor-mstatus">Machine status (<code>mstatus</code>) register for RV64 when the hypervisor extension is implemented.</a> shows the modified
<code>mstatus</code> register when the hypervisor extension is implemented and
MXLEN=64. When MXLEN=32, the hypervisor extension adds MPV and GVA not
to <code>mstatus</code> but to <code>mstatush</code>.
<a href="#hypervisor-mstatush">Additional machine status (<code>mstatush</code>) register for RV32 when the hypervisor extension is implemented.  The format of <code>mstatus</code> is unchanged for RV32.</a> shows the
<code>mstatush</code> register when the hypervisor extension is implemented and
MXLEN=32.</p>
</div>
<div id="hypervisor-mstatus" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrlllFr2zAUhd_7K4SeEobBkl0v9dvG1lFYwMRNGih9UGo5MXNsI2ukW8l_nzI3deQi7a6JC2NPBp1zj2Tp6rMHCU-ZlKJGYZWzrEC3T8_HMC0L6aRsneU_EB6_Q6RClyzPF-z-G0aNWmc_OaL-9m54NlBBSJQbZ8Wz5Uoi30XaIEu4cNICFVn-NJ7zVDprJpZqNs_dm3fFL0YX5QOvnUolqDDk0eGZGhds4ygB4cDDarl1xVQFChelUFPV6HG7HWou-uzyUSj5g3RYcb8qBcK1ZEJic6nvGkt5kVgKvQvIyrwRyPUe5ApArvNnF7W4fJDLA7kowKV6Q5k08TAj_tS-m1Y32B0JwjfR5ArvG3fTtCFelHnSbdfhPmakL3IczQwz4C-zDyZp_PGzSYot0vzrLQndu7azdH1q1ztbFcqy2m-r870QPGeSJ7sRKcv1S6W7tQTSNbQ96ZHZBYp6Y5N29Y8x2Tu0UZvFdLvcHnJ4U7Q3amCTZ8viz5iinqnSTilKQXsI22kXdGggLhIQFwmIiySAUIr85qJRBfGQeJYMSP8cdalPAMVAf5_reGJi2PWNUZmNjbicG_PiqbkqmhjZPI91UnbkS6t8WpDar3bb9cG_xc8-SHyk6Q1ITOjf3eTDUmIFifvq4Atb7gjCJxAuQbQ8hyT5oP_Rk7UOqAnN36i-YKz4FVkhNbMzLI6i9kS6yVfGn8zpwf8n7SYay1795egyu_cZ4n5mAN9G2kPf0pNhmP5XH5lfB89ocA==?id=hypervisor-mstatus" alt="Machine status (`mstatus`) register for RV64 when the hypervisor extension is implemented.">
</div>
<div class="title">Figure 32. Machine status (<code>mstatus</code>) register for RV64 when the hypervisor extension is implemented.</div>
</div>
<div id="hypervisor-mstatush" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq9Us1LwzAUv--veOTUIoF-WUdvE1Q8FIbCPIiHdE3XYpaUJNDp6P9uxtZ1nUaqh50Cv4_3fu-9ODktiNZSQVIzUnF4PbzbpBBc44KsK_YBKL0Cv4Z7wlhGlu8I9qyqPikEUfvmThxTCKRocEmrVakh8mAAkpxKXHDgFTvgjBYar4lcmW6h14l35m9oJjZU4dpUMMUgDNyJwSVpsCEAhT4ycVVNOEwh0XSjMeHLUkhAShOpTdpMSNNfwbZt3VPr1OqkPP_Fd3P0hXZRPEZ0PUYUjRGFR1Hwxy14VucPWzgxOjstoJf50yPqPkyzPz_KBMvPv4nbtfHjYYB0vugnHFIPi5mNSm_vbNSzlfp35mg4Owr6o_ixfbf-mNNdWNQnj4aiLyb-S34=?id=hypervisor-mstatush" alt="Additional machine status (`mstatush`) register for RV32 when the hypervisor extension is implemented.  The format of `mstatus` is unchanged for RV32.">
</div>
<div class="title">Figure 33. Additional machine status (<code>mstatush</code>) register for RV32 when the hypervisor extension is implemented.  The format of <code>mstatus</code> is unchanged for RV32.</div>
</div>
<div class="paragraph">
<p>The MPV bit (Machine Previous Virtualization Mode) is written by the
implementation whenever a trap is taken into M-mode. Just as the MPP
field is set to the (nominal) privilege mode at the time of the trap,
the MPV bit is set to the value of the virtualization mode V at the time
of the trap. When an MRET instruction is executed, the virtualization
mode V is set to MPV, unless MPP=3, in which case V remains 0.</p>
</div>
<div class="paragraph">
<p>Field GVA (Guest Virtual Address) is written by the implementation
whenever a trap is taken into M-mode. For any trap (breakpoint, address
misaligned, access fault, page fault, or guest-page fault) that writes a
guest virtual address to <code>mtval</code>, GVA is set to 1. For any other trap
into M-mode, GVA is set to 0.</p>
</div>
<div class="paragraph">
<p>The TSR and TVM fields of <code>mstatus</code> affect execution only in HS-mode,
not in VS-mode. The TW field affects execution in all modes except
M-mode.</p>
</div>
<div class="paragraph">
<p>Setting TVM=1 prevents HS-mode from accessing <code>hgatp</code> or executing
HFENCE.GVMA or HINVAL.GVMA, but has no effect on accesses to <code>vsatp</code> or
instructions HFENCE.VVMA or HINVAL.VVMA.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>TVM exists in <code>mstatus</code> to allow machine-level software to modify the
address translations managed by a supervisor-level OS, usually for the
purpose of inserting another stage of address translation below that
controlled by the OS. The instruction traps enabled by TVM=1 permit
machine level to co-opt both <code>satp</code> and <code>hgatp</code> and substitute <em>shadow
page tables</em> that merge the OSâ€™s chosen page translations with M-levelâ€™s
lower-stage translations, all without the OS being aware. M-level
software needs this ability not only to emulate the hypervisor extension
if not already supported, but also to emulate any future RISC-V
extensions that may modify or add address translation stages, perhaps,
for example, to improve support for nested hypervisors, i.e., running
hypervisors atop other hypervisors.</p>
</div>
<div class="paragraph">
<p>However, setting TVM=1 does not cause traps for accesses to <code>vsatp</code> or
instructions HFENCE.VVMA or HINVAL.VVMA, or for any actions taken in
VS-mode, because M-level software is not expected to need to involve
itself in VS-stage address translation. For virtual machines, it should
be sufficient, and in all likelihood faster as well, to leave VS-stage
address translation alone and merge all other translation stages into
G-stage shadow page tables controlled by <code>hgatp</code>. This assumption does
place some constraints on possible future RISC-V extensions that current
machines will be able to emulate efficiently.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The hypervisor extension changes the behavior of the Modify Privilege
field, MPRV, of <code>mstatus</code>. When MPRV=0, translation and protection
behave as normal. When MPRV=1, explicit memory accesses are translated
and protected, and endianness is applied, as though the current
virtualization mode were set to MPV and the current nominal privilege
mode were set to MPP. <a href="#h-mprv">Effect of MPRV on the translation and protection of explicit memory accesses.</a> enumerates the cases.</p>
</div>
<table id="h-mprv" class="tableblock frame-all grid-all stretch center">
<caption class="title">Table 5. Effect of MPRV on the translation and protection of explicit memory accesses.</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 9.5238%;">
<col style="width: 9.5238%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">MPRV</th>
<th class="tableblock halign-center valign-top">MPV</th>
<th class="tableblock halign-center valign-top">MPP</th>
<th class="tableblock halign-left valign-top">Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Normal access; current privilege mode applies.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U-level access with HS-level translation and protection only.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HS-level access with HS-level translation and protection only.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">M-level access with no translation.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VU-level access with two-stage translation and protection. The
HS-level MXR bit makes any executable page readable. <code>vsstatus</code>.MXR
makes readable those pages marked executable at the VS translation
stage, but only if readable at the guest-physical translation stage.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VS-level access with two-stage translation and protection. The
HS-level MXR bit makes any executable page readable. <code>vsstatus</code>.MXR
makes readable those pages marked executable at the VS translation
stage, but only if readable at the guest-physical translation stage.
<code>vsstatus</code>.SUM applies instead of the HS-level SUM bit.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>MPRV does not affect the virtual-machine load/store instructions, HLV,
HLVX, and HSV. The explicit loads and stores of these instructions
always act as though V=1 and the nominal privilege mode were
<code>hstatus</code>.SPVP, overriding MPRV.</p>
</div>
<div class="paragraph">
<p>The <code>mstatus</code> register is a superset of the HS-level <code>sstatus</code> register
but is not a superset of <code>vsstatus</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="machine-interrupt-delegation-mideleg-register"><a class="anchor" href="#machine-interrupt-delegation-mideleg-register"></a>Machine Interrupt Delegation (<code>mideleg</code>) Register</h4>
<div class="paragraph">
<p>When the hypervisor extension is implemented, bits 10, 6, and 2 of
<code>mideleg</code> (corresponding to the standard VS-level interrupts) are each
read-only one. Furthermore, if any guest external interrupts are
implemented (GEILEN is nonzero), bit 12 of <code>mideleg</code> (corresponding to
supervisor-level guest external interrupts) is also read-only one.
VS-level interrupts and guest external interrupts are always delegated
past M-mode to HS-mode.</p>
</div>
<div class="paragraph">
<p>For bits of <code>mideleg</code> that are zero, the corresponding bits in
<code>hideleg</code>, <code>hip</code>, and <code>hie</code> are read-only zeros.</p>
</div>
</div>
<div class="sect3">
<h4 id="machine-interrupt-mip-and-mie-registers"><a class="anchor" href="#machine-interrupt-mip-and-mie-registers"></a>Machine Interrupt (<code>mip</code> and <code>mie</code>) Registers</h4>
<div class="paragraph">
<p>The hypervisor extension gives registers <code>mip</code> and <code>mie</code> additional
active bits for the hypervisor-added interrupts. <a href="#hypervisor-mipreg-standard">Standard portion (bits 15:0) of <code>mip</code>.</a> and <a href="#hypervisor-miereg-standard">Standard portion (bits 15:0) of <code>mie</code>.</a> show the
standard portions (bits 15:0) of registers <code>mip</code> and <code>mie</code> when the
hypervisor extension is implemented.</p>
</div>
<div id="hypervisor-mipreg-standard" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrtkstqwzAQRff5isGrmCLwK31kW5JSqGnBpZuShdzIiahiG1mQtsH_XoWmD6VoGMgmi6wMc87cK2QN56LixugOxq3isobn3XczrprasIqvpHqHID-DuIUpV6rkL68BfNFOfghIsn4WDoY2CHSzZkshF0sDWQTOkM-FZlUNtVS7uRKVYSuuF7Ytjb7l7fK_adm8iY61NsGGQZqEAzvXfM0sgCAeBfa4ZaNtRQebvg8dmqE03dKu5bYN_FbyYyWIFZOsiNJ4RYm6pEgXFOmcIo0oUkaRUopEu3OKFHklj-Wu313fT28ffv-aS4ubyR-4t5oj7KmYIKnIoveg-SPWhkCM-dsKrA2BGHPbDngO6YFvJj7qupO0L30CGjIiSQ==?id=hypervisor-mipreg-standard" alt="Standard portion (bits 15:0) of `mip`.">
</div>
<div class="title">Figure 34. Standard portion (bits 15:0) of <code>mip</code>.</div>
</div>
<div id="hypervisor-miereg-standard" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrtkstqwzAQRff5isGrmCLwK31kG5xSqOnCpZvShdzIiahiG0mQtsH_XoWmD6V4GMimi6wMc87cK2SNF6Lm1moD005x2cDj_rud1m1jWc3XUr1BUJxB3MGcK1Xx55cAPqmR7wKSrH8KR2MXBLrdsJWQy5WFLAJvyBdCs7qBRqr9XInasjXXS9eWRl_ybvnPtGpfhWGdS3BhkCbhyM013zAHIIgngTtu1WpXYWDb96FHM5SmO2o67tpg2Eq-rQSxYpIVURqvKFGXFOmCIp1TpAlFyihSSpFod06RokFpwPLXb2d385v856_5tLzOf8GD1QJhD2WOpCKLgwct7rE2BGJsuK3E2hCIMb_tiOeQHvlm4n9dd5IOpQ-wXiHQ?id=hypervisor-miereg-standard" alt="Standard portion (bits 15:0) of `mie`.">
</div>
<div class="title">Figure 35. Standard portion (bits 15:0) of <code>mie</code>.</div>
</div>
<div class="paragraph">
<p>Bits SGEIP, VSEIP, VSTIP, and VSSIP in <code>mip</code> are aliases for the same
bits in hypervisor CSR <code>hip</code>, while SGEIE, VSEIE, VSTIE, and VSSIE in
<code>mie</code> are aliases for the same bits in <code>hie</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="machine-second-trap-value-mtval2-register"><a class="anchor" href="#machine-second-trap-value-mtval2-register"></a>Machine Second Trap Value (<code>mtval2</code>) Register</h4>
<div class="paragraph">
<p>The <code>mtval2</code> register is an MXLEN-bit read/write register formatted as
shown in <a href="#mtval2reg">Machine second trap value register (<code>mtval2</code>).</a>. When a trap is taken into
M-mode, <code>mtval2</code> is written with additional exception-specific
information, alongside <code>mtval</code>, to assist software in handling the trap.</p>
</div>
<div id="mtval2reg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNp9jkuLwjAUhff-iktXLRLoCxfd68qZ9YC4uLWJDaZJSS7jo_S_e51RsQzjKnDOPV--uJEKiXyAqjeoLWzu71ApZ0ko7LQ5Q_Qxh6yHFRpT4-4QwW8b9EVCXo7bZBYzCLw7ilbqfUtQpjAJsZFeKAtWm3tupCLRod_zb0X6OL6N_6S1O8kgeiYwDIo8mXHu8Si4YLev9fJTZBE7hx4tZAuoSJ5IoN21zkMUCD2xc-08WwQYxjF5BaT_T6Vt3gw7-kaTP9dFPq1_xF7aKegK9BB53w==?id=mtval2reg" alt="Machine second trap value register (`mtval2`).">
</div>
<div class="title">Figure 36. Machine second trap value register (<code>mtval2</code>).</div>
</div>
<div class="paragraph">
<p>When a guest-page-fault trap is taken into M-mode, <code>mtval2</code> is written
with either zero or the guest physical address that faulted, shifted
right by 2 bits. For other traps, <code>mtval2</code> is set to zero, but a future
standard or extension may redefine <code>mtval2&#8217;s</code> setting for other traps.</p>
</div>
<div class="paragraph">
<p>If a guest-page fault is due to an implicit memory access during
first-stage (VS-stage) address translation, a guest physical address
written to <code>mtval2</code> is that of the implicit memory access that faulted.
Additional information is provided in CSR <code>mtinst</code> to disambiguate such
situations.</p>
</div>
<div class="paragraph">
<p>Otherwise, for misaligned loads and stores that cause guest-page faults,
a nonzero guest physical address in <code>mtval2</code> corresponds to the faulting
portion of the access as indicated by the virtual address in <code>mtval</code>.
For instruction guest-page faults on systems with variable-length
instructions, a nonzero <code>mtval2</code> corresponds to the faulting portion of
the instruction as indicated by the virtual address in <code>mtval</code>.</p>
</div>
<div class="paragraph">
<p><code>mtval2</code> is a <strong>WARL</strong> register that must be able to hold zero and may be
capable of holding only an arbitrary subset of other 2-bit-shifted guest
physical addresses, if any.</p>
</div>
<div class="paragraph">
<p>The Ssdbltrap extension (See <a href="#ssdbltrp">[ssdbltrp]</a>) requires the implementation of
the <code>mtval2</code> CSR.</p>
</div>
</div>
<div class="sect3">
<h4 id="machine-trap-instruction-mtinst-register"><a class="anchor" href="#machine-trap-instruction-mtinst-register"></a>Machine Trap Instruction (<code>mtinst</code>) Register</h4>
<div class="paragraph">
<p>The <code>mtinst</code> register is an MXLEN-bit read/write register formatted as
shown in <a href="#mtinstreg">Machine trap instruction (<code>mtinst</code>) register.</a>. When a trap is taken into
M-mode, <code>mtinst</code> is written with a value that, if nonzero, provides
information about the instruction that trapped, to assist software in
handling the trap. The values that may be written to <code>mtinst</code> on a trap
are documented in <a href="#tinst-vals">Transformed Instruction or Pseudoinstruction for <code>mtinst</code> or <code>htinst</code></a>.</p>
</div>
<div id="mtinstreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNp9jssKwjAQRfd-xdCVRQJ9iIvudaWuBXExtYkNpklJBnzRf3d8YhFdBe6de3KGlVRI5AMUrUFtYf18L4VyloTCRpsTRIsRpC3M0JgSt_sIHm3QZwnZuNvEgyGDwLuDqKXe1QTjBHohVtILZcFq88yNVCQa9Dv-LU9ex7fxV1q6owyiZQLDIM_iAeceD4ILdlvNp0uRRuwcWrSQTqAgeSSBdls7D1Eg9MTOpfNsEeDSdfEnIPk9lbb6M2xI20DvdZ7167vYR9sHXQEEEXoo?id=mtinstreg" alt="Machine trap instruction (`mtinst`) register.">
</div>
<div class="title">Figure 37. Machine trap instruction (<code>mtinst</code>) register.</div>
</div>
<div class="paragraph">
<p><code>mtinst</code> is a <strong>WARL</strong> register that need only be able to hold the values that
the implementation may automatically write to it on a trap.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="two-stage-translation"><a class="anchor" href="#two-stage-translation"></a>Two-Stage Address Translation</h3>
<div class="paragraph">
<p>Whenever the current virtualization mode V is 1, two-stage address
translation and protection is in effect. For any virtual memory access,
the original virtual address is converted in the first stage by VS-level
address translation, as controlled by the <code>vsatp</code> register, into a
<em>guest physical address</em>. The guest physical address is then converted
in the second stage by guest physical address translation, as controlled
by the <code>hgatp</code> register, into a supervisor physical address. The two
stages are known also as VS-stage and G-stage translation. Although
there is no option to disable two-stage address translation when V=1,
either stage of translation can be effectively disabled by zeroing the
corresponding <code>vsatp</code> or <code>hgatp</code> register.</p>
</div>
<div class="paragraph">
<p>The <code>vsstatus</code> field MXR, which makes execute-only pages readable by explicit loads, only
overrides VS-stage page protection. Setting MXR at VS-level does not
override guest-physical page protections. Setting MXR at HS-level,
however, overrides both VS-stage and G-stage execute-only permissions.</p>
</div>
<div class="paragraph">
<p>When V=1, memory accesses that would normally bypass address translation
are subject to G-stage address translation alone. This includes memory
accesses made in support of VS-stage address translation, such as reads
and writes of VS-level page tables.</p>
</div>
<div class="paragraph">
<p>Machine-level physical memory protection applies to supervisor physical
addresses and is in effect regardless of virtualization mode.</p>
</div>
<div class="sect3">
<h4 id="guest-addr-translation"><a class="anchor" href="#guest-addr-translation"></a>Guest Physical Address Translation</h4>
<div class="paragraph">
<p>The mapping of guest physical addresses to supervisor physical addresses
is controlled by CSR <code>hgatp</code> (<a href="#hgatp">Hypervisor Guest Address Translation and Protection (<code>hgatp</code>) Register</a>).</p>
</div>
<div class="paragraph">
<p>When the address translation scheme selected by the MODE field of
<code>hgatp</code> is Bare, guest physical addresses are equal to supervisor
physical addresses without modification, and no memory protection
applies in the trivial translation of guest physical addresses to
supervisor physical addresses.</p>
</div>
<div class="paragraph">
<p>When <code>hgatp</code>.MODE specifies a translation scheme of Sv32x4, Sv39x4,
Sv48x4, or Sv57x4, G-stage address translation is a variation on the
usual page-based virtual address translation scheme of Sv32, Sv39, Sv48,
or Sv57, respectively. In each case, the size of the incoming address is
widened by 2 bits (to 34, 41, 50, or 59 bits). To accommodate the
2 extra bits, the root page table (only) is expanded by a factor of four
to be 16 KiB instead of the usual 4 KiB. Matching its larger size, the
root page table also must be aligned to a 16 KiB boundary instead of the
usual 4 KiB page boundary. Except as noted, all other aspects of Sv32,
Sv39, Sv48, or Sv57 are adopted unchanged for G-stage translation.
Non-root page tables and all page table entries (PTEs) have the same
formats as documented in <a href="#sv32">[sv32]</a>, <a href="#sv39">[sv39]</a>, <a href="#sv48">[sv48]</a>, and <a href="#sv57">[sv57]</a>.</p>
</div>
<div class="paragraph">
<p>For Sv32x4, an incoming guest physical address is partitioned into a
virtual page number (VPN) and page offset as shown in
<a href="#sv32x4va">Sv32x4 virtual address (guest physical address).</a>. This partitioning is identical to
that for an Sv32 virtual address as depicted in
<a href="#sv32va">[sv32va]</a>, except with 2 more bits at the
high end in VPN[1]. (Note that the fields of a partitioned guest
physical address also correspond one-for-one with the structure that
Sv32 assigns to a physical address, depicted in
<a href="#sv32va">[sv32va]</a>.)</p>
</div>
<div id="sv32x4va" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq1Ub1qwzAQ3vMUh6aYIpAsE4IfoFtLpy4hwzmWbFNFEpIgaYPfvQpN0pRggw2dDr7f425ZS4Ux-gCl09gZ2FzmqVTWRKpw3-lPIC9PwB08o9YV7j4I_LCh-5KQF_02WyxTEHh7oK3smjZCweAPiLX0VBkwnb7gWqpI9-ib1CbYVXw2P6CVPcpAXUpIYSDybJFwjweaiHNi2jY4NLCCsrI-NQU49X12JyJCkKtKQBnlMVI0u9Z6ICGij2TYmueDVmnqMSOf3cnndvLfzmJiJxt0jlaO3H_yl97fXjd8e9tj9ciyQdZhI8EqFWS8Sdb_tundg8ZUjEzLWs848zcvnjn6?id=sv32x4va" alt="Sv32x4 virtual address (guest physical address).">
</div>
<div class="title">Figure 38. Sv32x4 virtual address (guest physical address).</div>
</div>
<div class="paragraph">
<p>For Sv39x4, an incoming guest physical address is partitioned as shown
in <a href="#sv39x4va">Sv39x4 virtual address (guest physical address).</a>. This partitioning is identical to that for an Sv39 virtual address as depicted in <a href="#sv39va">[sv39va]</a>, except with 2 more bits at the
high end in VPN[2]. Address bits 63:41 must all be zeros, or else a
guest-page-fault exception occurs.</p>
</div>
<div id="sv39x4va" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq1Uk9rwjAUv_spHjlZRqBNy9B-gN02PHkRD682acNiUpKAbtLvvsh0KtKCYZ4Cv7_v8TKtuUDvrYOyUyg1rE7voRRGeypwK9UXkPcXyDp4Q6Uq3HwS-GWd_ObAin6dTKYhCKzZ0ZbLpvVQpHADYs0tFRq0VCdcceHpFm0T2vL0LD6a79DK7LmjXUgIYZCzZBJwizsaiGNimNZ1qOEVysrY0OTg0PfJlYgUKTmrGJSe7z1FvWmNBeI8Wk-Grfmwlet6xMjm0Z0si-2M3zNjkZ3ZZdjiwc500DlaOXLzh3_GcvGxYuvLHPdsNsqmg2yHDQcjhOP-TzJ72h63VxhSzf9NdPVdZhGH-gFGQnRy?id=sv39x4va" alt="Sv39x4 virtual address (guest physical address).">
</div>
<div class="title">Figure 39. Sv39x4 virtual address (guest physical address).</div>
</div>
<div class="paragraph">
<p>For Sv48x4, an incoming guest physical address is partitioned as shown
in <a href="#sv48x4va">Sv48x4 virtual address (guest physical address).</a>. This partitioning is identical to
that for an Sv48 virtual address as depicted in
<a href="#sv48va">[sv48va]</a>, except with 2 more bits at the
high end in VPN[3]. Address bits 63:50 must all be zeros, or else a
guest-page-fault exception occurs.</p>
</div>
<div id="sv48x4va" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq9Ur1qwzAQ3vMUh6aYIrBkURo_QLeWTFlChnMs2aaKZCRB0ga_exWaFJdgQ0XpJPh-7rvT3bKWCkNwHspeY2dge33PpbImUIWHTr8DeXkA1sMzal3h_o3AF-u7DwlcDLtssYyFwNkjbWXXtAFEDj9ArKWjyoDp9BXXUgV6QNfEtCK_iS_mO7SyJ-lpHyvEYlDwbBFxh0caiUvF2K3v0cAjlJV1McnDeRiykYiIFbmpOJRBngJFs2-tA-IDukCmrcW0VZp6zviUnpknZvL0OTlLzcyTMxlPzGQsOTPxa2fu7NfXuFm_bovddx_inuWzLJtl80m2x0aCVcrLMCH5yylHOxLTqtX_ikYXJxJ2_Qkn3a8q?id=sv48x4va" alt="Sv48x4 virtual address (guest physical address).">
</div>
<div class="title">Figure 40. Sv48x4 virtual address (guest physical address).</div>
</div>
<div class="paragraph">
<p>For Sv57x4, an incoming guest physical address is partitioned as shown
in <a href="#sv57x4va">Sv57x4 virtual address (guest physical address).</a>. This partitioning is identical to
that for an Sv57 virtual address as depicted in
<a href="#sv57va">[sv57va]</a>, except with 2 more bits at the
high end in VPN[4]. Address bits 63:59 must all be zeros, or else a
guest-page-fault exception occurs.</p>
</div>
<div id="sv57x4va" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrNk79qwzAQxvc8xaEppgisP6W1H6BbS6cuIYMcS7GpIhlJkLTB716FJsUlWFDRIZPgvu_udzqdlq1UIgTnoR606A2szuexVtYErMSu1x-Anu-ADPAktG7E5h3Bt-r7TwmUj-tisYyFwNk97mS_7QLwEn4FRSsdVgZMr89xLVXAO-G2kcbKi_mUfBVt7EF6PMQKsRgwWixi3Ik9jsKpYuzWD8IAh7qxLpI8HMexmJjQ_SO6uCjUQR4CFmbTWQfIB-ECmk_l86nStKnEh2wmqzKZLP-erMxk0iqbSUkus8xmEprJJCSbmTnaxG7_-Qe8vb6s-PqnD36tsqRKkypJquWsOoitBKuUl2HG8p8zmLxgwlXdoGmytDxjXb4AM0_p2g==?id=sv57x4va" alt="Sv57x4 virtual address (guest physical address).">
</div>
<div class="title">Figure 41. Sv57x4 virtual address (guest physical address).</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The page-based G-stage address translation scheme for RV32, Sv32x4, is
defined to support a 34-bit guest physical address so that an RV32
hypervisor need not be limited in its ability to virtualize real 32-bit
RISC-V machines, even those with 33-bit or 34-bit physical addresses.
This may include the possibility of a machine virtualizing itself, if it
happens to use 33-bit or 34-bit physical addresses. Multiplying the size
and alignment of the root page table by a factor of four is the cheapest
way to extend Sv32 to cover a 34-bit address. The possible wastage of
12 KiB for an unnecessarily large root page table is expected to be of
negligible consequence for most (maybe all) real uses.</p>
</div>
<div class="paragraph">
<p>A consistent ability to virtualize machines having as much as four times
the physical address space as virtual address space is believed to be of
some utility also for RV64. For a machine implementing 39-bit virtual
addresses (Sv39), for example, this allows the hypervisor extension to
support up to a 41-bit guest physical address space without either
necessitating hardware support for 48-bit virtual addresses (Sv48) or
falling back to emulating the larger address space using shadow page
tables.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The conversion of an Sv32x4, Sv39x4, Sv48x4, or Sv57x4 guest physical
address is accomplished with the same algorithm used for Sv32, Sv39,
Sv48, or Sv57, as presented in
<a href="#sv32algorithm">[sv32algorithm]</a>, except that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hgatp</code> substitutes for the usual <code>satp</code>;</p>
</li>
<li>
<p>for the translation to begin, the effective privilege mode must be
VS-mode or VU-mode;</p>
</li>
<li>
<p>when checking the U bit, the current privilege mode is always taken to
be U-mode; and</p>
</li>
<li>
<p>guest-page-fault exceptions are raised instead of regular page-fault
exceptions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For G-stage address translation, all memory accesses (including those
made to access data structures for VS-stage address translation) are
considered to be user-level accesses, as though executed in U-mode.
Access type permissionsâ€”readable, writable, or executableâ€”are checked
during G-stage translation the same as for VS-stage translation. For a
memory access made to support VS-stage address translation (such as to
read/write a VS-level page table), permissions and the need to set A
and/or D bits at the G-stage level are checked as though for an implicit
load or store, not for the original access type. However, any exception
is always reported for the original access type (instruction, load, or
store/AMO).</p>
</div>
<div class="paragraph">
<p>The G bit in all G-stage PTEs is currently not used. Until
its use is defined by a standard extension, it should be cleared by
software for forward compatibility, and must be ignored by hardware.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>G-stage address translation uses the identical format for PTEs as
regular address translation, even including the U bit, due to the
possibility of sharing some (or all) page tables between G-stage
translation and regular HS-level address translation. Regardless of
whether this usage will ever become common, we chose not to preclude it.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="guest-page-faults"><a class="anchor" href="#guest-page-faults"></a>Guest-Page Faults</h4>
<div class="paragraph">
<p>Guest-page-fault traps may be delegated from M-mode to HS-mode under the
control of CSR <code>medeleg</code>, but cannot be delegated to other privilege
modes. On a guest-page fault, CSR <code>mtval</code> or <code>stval</code> is written with the
faulting guest virtual address as usual, and <code>mtval2</code> or <code>htval</code> is
written either with zero or with the faulting guest physical address,
shifted right by 2 bits. CSR <code>mtinst</code> or <code>htinst</code> may also be written
with information about the faulting instruction or other reason for the
access, as explained in <a href="#tinst-vals">Transformed Instruction or Pseudoinstruction for <code>mtinst</code> or <code>htinst</code></a>.</p>
</div>
<div class="paragraph">
<p>When an instruction fetch or a misaligned memory access straddles a page
boundary, two different address translations are involved. When a
guest-page fault occurs in such a circumstance, the faulting virtual
address written to <code>mtval</code>/<code>stval</code> is the same as would be required for
a regular page fault. Thus, the faulting virtual address may be a
page-boundary address that is higher than the instruction&#8217;s original
virtual address, if the byte at that page boundary is among the accessed
bytes.</p>
</div>
<div class="paragraph">
<p>When a guest-page fault is not due to an implicit memory access for
VS-stage address translation, a nonzero guest physical address written
to <code>mtval2</code>/<code>htval</code> shall correspond to the exact virtual address
written to <code>mtval</code>/<code>stval</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="hyp-mm-fences"><a class="anchor" href="#hyp-mm-fences"></a>Memory-Management Fences</h4>
<div class="paragraph">
<p>The behavior of the SFENCE.VMA instruction is affected by the current
virtualization mode V. When V=0, the virtual-address argument is an
HS-level virtual address, and the ASID argument is an HS-level ASID. The
instruction orders stores only to HS-level address-translation
structures with subsequent HS-level address translations.</p>
</div>
<div class="paragraph">
<p>When V=1, the virtual-address argument to SFENCE.VMA is a guest virtual
address within the current virtual machine, and the ASID argument is a
VS-level ASID within the current virtual machine. The current virtual
machine is identified by the VMID field of CSR <code>hgatp</code>, and the
effective ASID can be considered to be the combination of this VMID with
the VS-level ASID. The SFENCE.VMA instruction orders stores only to the
VS-level address-translation structures with subsequent VS-stage address
translations for the same virtual machine, i.e., only when <code>hgatp</code>.VMID
is the same as when the SFENCE.VMA executed.</p>
</div>
<div class="paragraph">
<p>Hypervisor instructions HFENCE.VVMA and HFENCE.GVMA provide additional
memory-management fences to complement SFENCE.VMA. These instructions
are described in <a href="#hfence.vma">Hypervisor Memory-Management Fence Instructions</a>.</p>
</div>
<div class="paragraph">
<p><a href="#pmp-vmem">[pmp-vmem]</a> discusses the intersection between
physical memory protection (PMP) and page-based address translation. It
is noted there that, when PMP settings are modified in a manner that
affects either the physical memory that holds page tables or the
physical memory to which page tables point, M-mode software must
synchronize the PMP settings with the virtual memory system. For
HS-level address translation, this is accomplished by executing in
M-mode an SFENCE.VMA instruction with <em>rs1</em>=<code>x0</code> and <em>rs2</em>=<code>x0</code>, after
the PMP CSRs are written. Synchronization with G-stage and VS-stage data
structures is also needed. Executing an HFENCE.GVMA instruction with
<em>rs1</em>=<code>x0</code> and <em>rs2</em>=<code>x0</code> suffices to flush all G-stage or VS-stage
address-translation cache entries that have cached PMP settings
corresponding to the final translated supervisor physical address. An
HFENCE.VVMA instruction is not required.</p>
</div>
<div class="paragraph">
<p>Similarly, if the setting of the PBMTE bit in <code>menvcfg</code> is changed, an
HFENCE.GVMA instruction with <em>rs1</em>=<code>x0</code> and <em>rs2</em>=<code>x0</code> suffices to synchronize
with respect to the altered interpretation of G-stage and VS-stage PTEs' PBMT
fields.</p>
</div>
<div class="paragraph">
<p>By contrast, if the PBMTE bit in <code>henvcfg</code> is changed, executing an
HFENCE.VVMA with <em>rs1</em>=<code>x0</code> and <em>rs2</em>=<code>x0</code> suffices to synchronize with
respect to the altered interpretation of VS-stage PTEs' PBMT fields for the
currently active VMID.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
No mechanism is provided to atomically change <code>vsatp</code> and <code>hgatp</code>
together.  Hence, to prevent speculative execution causing one guest&#8217;s
VS-stage translations to be cached under another guest&#8217;s VMID, world-switch
code should zero <code>vsatp</code>, then swap <code>hgatp</code>, then finally write the new
<code>vsatp</code> value.  Similarly, if <code>henvcfg</code>.PBMTE need be world-switched, it
should be switched after zeroing <code>vsatp</code> but before writing the new <code>vsatp</code>
value,Â obviating the need to execute an HFENCE.VVMA instruction.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="traps"><a class="anchor" href="#traps"></a>Traps</h3>
<div class="sect3">
<h4 id="sec:hcauses"><a class="anchor" href="#sec:hcauses"></a>Trap Cause Codes</h4>
<div class="paragraph">
<p>The hypervisor extension augments the trap cause encoding.
<a href="#hcauses">Machine and supervisor cause register (<code>mcause</code> and <code>scause</code>) values when the hypervisor extension is implemented.</a> lists the possible M-mode and HS-mode
trap cause codes when the hypervisor extension is implemented. Codes are
added for VS-level interrupts (interrupts 2, 6, 10), for
supervisor-level guest external interrupts (interrupt 12), for
virtual-instruction exceptions (exception 22), and for guest-page faults
(exceptions 20, 21, 23). Furthermore, environment calls from VS-mode are
assigned cause 10, whereas those from HS-mode or S-mode use cause 9 as
usual.</p>
</div>
<table id="hcauses" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 6. Machine and supervisor cause register (<code>mcause</code> and <code>scause</code>) values when the hypervisor extension is implemented.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-top">Interrupt</th>
<th class="tableblock halign-right valign-top">Exception Code</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1<br>
1<br>
1<br>
1</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0<br>
1<br>
2<br>
3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved</em><br>
Supervisor software interrupt<br>
Virtual supervisor software interrupt<br>
Machine software interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1<br>
1<br>
1<br>
1</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">4<br>
5<br>
6<br>
7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved</em><br>
Supervisor timer interrupt<br>
Virtual supervisor timer interrupt<br>
Machine timer interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1<br>
1<br>
1<br>
1</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">8<br>
9<br>
10<br>
11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved</em><br>
Supervisor external interrupt<br>
Virtual supervisor external interrupt<br>
Machine external interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1<br>
1<br>
1<br>
1</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">12<br>
13<br>
14-15<br>
&#8805;16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supervisor guest external interrupt<br>
<em>Reserved for counter-overflow interrupt</em><br>
<em>Reserved</em><br>
<em>Designated for platform use</em></p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
16<br>
17<br>
18<br>
19<br>
20<br>
21<br>
22<br>
23<br>
24-31<br>
32-47<br>
48-63<br>
&#8805;64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction address misaligned<br>
Instruction access fault <br>
Illegal instruction <br>
Breakpoint <br>
Load address misaligned<br>
Load access fault<br>
Store/AMO address misaligned<br>
Store/AMO access fault<br>
Environment call from U-mode or VU-mode<br>
Environment call from HS-mode<br>
Environment call from VS-mode<br>
Environment call from M-mode<br>
Instruction page fault<br>
Load page fault<br>
<em>Reserved</em><br>
Store/AMO page fault<br>
Double trap<br>
<em>Reserved</em> <br>
Software check<br>
Hardware error<br>
Instruction guest-page fault<br>
Load guest-page fault<br>
Virtual instruction<br>
Store/AMO guest-page fault<br>
<em>Designated for custom use</em><br>
<em>Reserved</em><br>
<em>Designated for custom use</em><br>
<em>Reserved</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>HS-mode and VS-mode ECALLs use different cause values so they can be
delegated separately.</p>
</div>
<div class="paragraph">
<p>When V=1, a virtual-instruction exception (code 22) is normally raised
instead of an illegal-instruction exception if the attempted instruction
is <em>HS-qualified</em> but is prevented from executing when V=1 either due to
insufficient privilege or because the instruction is expressly disabled
by a supervisor or hypervisor CSR such as <code>scounteren</code> or <code>hcounteren</code>.
An instruction is <em>HS-qualified</em> if it would be valid to execute in
HS-mode (for some values of the instruction&#8217;s register operands),
assuming fields TSR and TVM of CSR <code>mstatus</code> are both zero.</p>
</div>
<div class="paragraph">
<p>A special rule applies for CSR instructions that access 32-bit high-half
CSRs such as <code>cycleh</code> and <code>htimedeltah</code>. When V=1 and
XLEN=32, an invalid attempt to access a high-half CSR
raises a virtual-instruction
exception instead of an illegal-instruction exception if the same CSR
instruction for the corresponding <em>low-half</em> CSR (e.g.<code>cycle</code> or
<code>htimedelta</code>) is HS-qualified.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When XLEN&gt;32, an attempt to access a high-half CSR
always raises an illegal-instruction exception.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Specifically, a virtual-instruction exception is raised for the
following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>in VS-mode, attempts to access a non-high-half counter CSR when the
corresponding bit in <code>hcounteren</code> is 0 and the same bit in <code>mcounteren</code>
is 1;</p>
</li>
<li>
<p>in VS-mode, if XLEN=32, attempts to access a high-half counter CSR
when the corresponding bit in <code>hcounteren</code> is 0 and the same bit in
<code>mcounteren</code> is 1;</p>
</li>
<li>
<p>in VU-mode, attempts to access a non-high-half counter CSR when the
corresponding bit in either <code>hcounteren</code> or <code>scounteren</code> is 0 and the
same bit in <code>mcounteren</code> is 1;</p>
</li>
<li>
<p>in VU-mode, if XLEN=32, attempts to access a high-half counter CSR
when the corresponding bit in either <code>hcounteren</code> or <code>scounteren</code> is 0
and the same bit in <code>mcounteren</code> is 1;</p>
</li>
<li>
<p>in VS-mode or VU-mode, attempts to execute a hypervisor instruction
(HLV, HLVX, HSV, or HFENCE);</p>
</li>
<li>
<p>in VS-mode or VU-mode, attempts to access an implemented non-high-half
hypervisor CSR or VS CSR when the same access (read/write) would be
allowed in HS-mode, assuming <code>mstatus</code>.TVM=0;</p>
</li>
<li>
<p>in VS-mode or VU-mode, if XLEN=32, attempts to access an implemented
high-half hypervisor CSR or high-half VS CSR when the same access
(read/write) to the CSR"s low-half partner would be allowed in HS-mode,
assuming <code>mstatus</code>.TVM=0;</p>
</li>
<li>
<p>in VU-mode, attempts to execute WFI when <code>mstatus</code>.TW=0, or to execute
a supervisor instruction (SRET or SFENCE);</p>
</li>
<li>
<p>in VU-mode, attempts to access an implemented non-high-half supervisor
CSR when the same access (read/write) would be allowed in HS-mode,
assuming <code>mstatus</code>.TVM=0;</p>
</li>
<li>
<p>in VU-mode, if XLEN=32, attempts to access an implemented high-half
supervisor CSR when the same access to the CSR&#8217;s low-half partner would
be allowed in HS-mode, assuming <code>mstatus</code>.TVM=0;</p>
</li>
<li>
<p>in VS-mode, attempts to execute WFI when <code>hstatus</code>.VTW=1 and
<code>mstatus</code>.TW=0, unless the instruction completes within an
implementation-specific, bounded time;</p>
</li>
<li>
<p>in VS-mode, attempts to execute SRET when <code>hstatus</code>.VTSR=1; and</p>
</li>
<li>
<p>in VS-mode, attempts to execute an SFENCE.VMA or SINVAL.VMA
instruction or to access <code>satp</code>, when <code>hstatus</code>.VTVM=1.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other extensions to the RISC-V Privileged Architecture may add to the
set of circumstances that cause a virtual-instruction exception when
V=1.</p>
</div>
<div class="paragraph">
<p>On a virtual-instruction trap, <code>mtval</code> or <code>stval</code> is written the same as
for an illegal-instruction trap.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is not unusual that hypervisors must emulate the instructions that
raise virtual-instruction exceptions, to support nested hypervisors or
for other reasons. Machine level is expected ordinarily to delegate
virtual-instruction traps directly to HS-level, whereas
illegal-instruction traps are likely to be processed first in M-mode before
being conditionally delegated (by software) to HS-level. Consequently,
virtual-instruction traps are expected typically to be handled faster
than illegal-instruction traps.</p>
</div>
<div class="paragraph">
<p>When not emulating the trapping instruction, a hypervisor should convert
a virtual-instruction trap into an illegal-instruction exception for the
guest virtual machine.</p>
</div>
<hr>
<div class="paragraph">
<p>Because TSR and TVM in <code>mstatus</code> are intended to impact only S-mode
(HS-mode), they are ignored for determining exceptions in VS-mode.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Fields FS and VS in registers <code>sstatus</code> and <code>vsstatus</code> deviate from the usual
<em>HS-qualified</em> rule.
If an instruction is prevented from executing because FS or VS is zero in
either <code>sstatus</code> or <code>vsstatus</code>, the exception raised is always an
illegal-instruction exception, never a virtual-instruction exception.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Early implementations of the H extension treated FS and VS in <code>sstatus</code> and
<code>vsstatus</code> specially this way, and the behavior has been codified to maintain
compatibility for software.</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<table id="HSyncExcPrio" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 7. Synchronous exception priority when the hypervisor extension is implemented.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Priority</th>
<th class="tableblock halign-right valign-top">Exc.Code</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Highest</em></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction address breakpoint</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-bottom"><p class="tableblock">12, 20, 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">During instruction address translation:<br>
&#160;&#160;&#160;First encountered page fault, guest-page fault, or access
fault</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-bottom"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">With physical address for instruction:<br>
&#160;&#160;&#160;Instruction access fault</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">2<br>
22<br>
0<br>
8, 9, 10, 11<br>
3<br>
3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Illegal instruction<br>
Virtual instruction<br>
Instruction address misaligned<br>
Environment call<br>
Environment break<br>
&#160;&#160;&#160;Load/store/AMO address breakpoint</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-bottom"><p class="tableblock">4,6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optionally:<br>
&#160;&#160;&#160;Load/store/AMO address misaligned</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-bottom"><p class="tableblock">13, 15, 21, 23, 5, 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">During address translation for an explicit memory access:<br>
&#160;&#160;&#160;First encountered page fault, guest-page fault,
or access fault</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-bottom"><p class="tableblock">5, 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">With physical address for an explicit memory access:<br>
&#160;&#160;&#160;Load/store/AMO access fault</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-bottom"><p class="tableblock"><em>Lowest</em></p></td>
<td class="tableblock halign-right valign-bottom"><p class="tableblock">4, 6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If not higher priority:<br>
&#160;&#160;&#160;Load/store/AMO address misaligned</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If an instruction may raise multiple synchronous exceptions, the
decreasing priority order of <a href="#HSyncExcPrio">Synchronous exception priority when the hypervisor extension is implemented.</a>
indicates which exception is taken and reported in <code>mcause</code> or <code>scause</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="trap-entry"><a class="anchor" href="#trap-entry"></a>Trap Entry</h4>
<div class="paragraph">
<p>When a trap occurs in HS-mode or U-mode, it goes to M-mode, unless
delegated by <code>medeleg</code> or <code>mideleg</code>, in which case it goes to HS-mode.
When a trap occurs in VS-mode or VU-mode, it goes to M-mode, unless
delegated by <code>medeleg</code> or <code>mideleg</code>, in which case it goes to HS-mode,
unless further delegated by <code>hedeleg</code> or <code>hideleg</code>, in which case it
goes to VS-mode.</p>
</div>
<div class="paragraph">
<p>When a trap is taken into M-mode, virtualization mode V gets set toÂ 0,
and fields MPV and MPP in <code>mstatus</code> (or <code>mstatush</code>) are set according to
<a href="#h-mpp">Value of <code>mstatus</code>/<code>mstatush</code> fields MPV and MPP after a trap into M-mode.  Upon trap return, MPV is ignored when MPP=3.</a>. A trap into M-mode also writes fields GVA,
MPIE, and MIE in <code>mstatus</code>/<code>mstatush</code> and writes CSRs <code>mepc</code>, <code>mcause</code>,
<code>mtval</code>, <code>mtval2</code>, and <code>mtinst</code>.</p>
</div>
<table id="h-mpp" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 8. Value of <code>mstatus</code>/<code>mstatush</code> fields MPV and MPP after a trap into M-mode.  Upon trap return, MPV is ignored when MPP=3.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Previous Mode</th>
<th class="tableblock halign-center valign-top">MPV</th>
<th class="tableblock halign-center valign-top">MPP</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">U-mode<br>
HS-mode<br>
M-mode</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<br>
0<br>
0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<br>
1<br>
3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VU-mode<br>
VS-mode</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<br>
1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<br>
1</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When a trap is taken into HS-mode, virtualization mode V is set to 0,
and <code>hstatus</code>.SPV and <code>sstatus</code>.SPP are set according to
<a href="#h-spp">Value of <code>hstatus</code> field SPV and <code>sstatus</code> field SPP after a trap into HS-mode.</a>. If V was 1 before the trap, field SPVP in
<code>hstatus</code> is set the same as <code>sstatus</code>.SPP; otherwise, SPVP is left
unchanged. A trap into HS-mode also writes field GVA in <code>hstatus</code>,
fields SPIE and SIE in <code>sstatus</code>, and CSRs <code>sepc</code>, <code>scause</code>, <code>stval</code>,
<code>htval</code>, and <code>htinst</code>.</p>
</div>
<table id="h-spp" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 9. Value of <code>hstatus</code> field SPV and <code>sstatus</code> field SPP after a trap into HS-mode.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Previous Mode</th>
<th class="tableblock halign-center valign-top">SPV</th>
<th class="tableblock halign-center valign-top">SPP</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">U-mode<br>
HS-mode<br></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<br>
0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<br>
1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VU-mode<br>
VS-mode</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1<br>
1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<br>
1</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When a trap is taken into VS-mode, <code>vsstatus</code>.SPP is set according to
<a href="#h-vspp">Value of <code>vsstatus</code> field SPP after a trap into VS-mode.</a>. Register <code>hstatus</code> and the HS-level
<code>sstatus</code> are not modified, and the virtualization mode V remains 1. A
trap into VS-mode also writes fields SPIE and SIE in <code>vsstatus</code> and
writes CSRs <code>vsepc</code>, <code>vscause</code>, and <code>vstval</code>.</p>
</div>
<table id="h-vspp" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 10. Value of <code>vsstatus</code> field SPP after a trap into VS-mode.</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Previous Mode</th>
<th class="tableblock halign-center valign-top">SPP</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VU-mode<br>
VS-mode</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0<br>
1</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="tinst-vals"><a class="anchor" href="#tinst-vals"></a>Transformed Instruction or Pseudoinstruction for <code>mtinst</code> or <code>htinst</code></h4>
<div class="paragraph">
<p>On any trap into M-mode or HS-mode, one of these values is written
automatically into the appropriate trap instruction CSR, <code>mtinst</code> or
<code>htinst</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>zero;</p>
</li>
<li>
<p>a transformation of the trapping instruction;</p>
</li>
<li>
<p>a custom value (allowed only if the trapping instruction is
non-standard); or</p>
</li>
<li>
<p>a special pseudoinstruction.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Except when a pseudoinstruction value is required (described later), the
value written to <code>mtinst</code> or <code>htinst</code> may always be zero, indicating
that the hardware is providing no information in the register for this
particular trap.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The value written to the trap instruction CSR serves two purposes. The
first is to improve the speed of instruction emulation in a trap
handler, partly by allowing the handler to skip loading the trapping
instruction from memory, and partly by obviating some of the work of
decoding and executing the instruction. The second purpose is to supply,
via pseudoinstructions, additional information about guest-page-fault
exceptions caused by implicit memory accesses done for VS-stage address
translation.</p>
</div>
<div class="paragraph">
<p>A <em>transformation</em> of the trapping instruction is written instead of
simply a copy of the original instruction in order to minimize the
burden for hardware yet still provide to a trap handler the information
needed to emulate the instruction. An implementation may at any time
reduce its effort by substituting zero in place of the transformed
instruction.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On an interrupt, the value written to the trap instruction register is
always zero. On a synchronous exception, if a nonzero value is written,
one of the following shall be true about the value:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bit 0 is <code>1</code>, and replacing bit 1 with <code>1</code> makes the value into a
valid encoding of a standard instruction.</p>
<div class="paragraph">
<p>In this case, the instruction that trapped is the same kind as indicated
by the register value, and the register value is the transformation of
the trapping instruction, as defined later. For example, if bits 1:0 are
binary <code>11</code> and the register value is the encoding of a standard LW
(load word) instruction, then the trapping instruction is LW, and the
register value is the transformation of the trapping LW instruction.</p>
</div>
</li>
<li>
<p>Bit 0 is <code>1</code>, and replacing bit 1 with <code>1</code> makes the value into an
instruction encoding that is explicitly designated for a custom
instruction (<em>not</em> an unused reserved encoding).</p>
<div class="paragraph">
<p>This is a <em>custom value</em>. The instruction that trapped is a non-standard
instruction. The interpretation of a custom value is not otherwise
specified by this standard.</p>
</div>
</li>
<li>
<p>The value is one of the special pseudoinstructions defined later, all
of which have bits 1:0 equal to <code>00</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These three cases exclude a large number of other possible values, such
as all those having bits 1:0 equal to binary <code>10</code>. A future standard or
extension may define additional cases, thus allowing values that are
currently excluded. Software may safely treat an unrecognized value in a
trap instruction register the same as zero.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To be forward-compatible with future revisions of this standard,
software that interprets a nonzero value from <code>mtinst</code> or <code>htinst</code> must
fully verify that the value conforms to one of the cases listed above.
For instance, for RV64, discovering that bits 6:0 of <code>mtinst</code> are
<code>0000011</code> and bits 14:12 are <code>010</code> is not sufficient to establish that
the first case applies and the trapping instruction is a standard LW
instruction; rather, software must also confirm that bits 63:32 of
<code>mtinst</code> are all zeros. A future standard might define new values for
64-bit <code>mtinst</code> that are nonzero in bits 63:32 yet may coincidentally
have in bits 31:0 the same bit patterns as standard RV64 instructions.</p>
</div>
<hr>
<div class="paragraph">
<p>Unlike for standard instructions, there is no requirement that the
instruction encoding of a custom value be of the same ``kind'' as the
instruction that trapped (or even have any correlation with the trapping
instruction).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#tinst-values">Values that may be automatically written to the trap instruction (<code>mtinst</code> or <code>htinst</code>) register on an exception trap.</a> shows the values that may be
automatically written to the trap instruction register for each standard
exception cause. For exceptions that prevent the fetching of an
instruction, only zero or a pseudoinstruction value may be written. A
custom value may be automatically written only if the instruction that
traps is non-standard. A future standard or extension may permit other
values to be written, chosen from the set of allowed values established
earlier.</p>
</div>
<div style="page-break-after: always;"></div>
<table id="tinst-values" class="tableblock frame-all grid-all stretch center">
<caption class="title">Table 11. Values that may be automatically written to the trap instruction (<code>mtinst</code> or <code>htinst</code>) register on an exception trap.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6669%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-bottom">Exception</th>
<th class="tableblock halign-center valign-bottom">Zero</th>
<th class="tableblock halign-center valign-top">Transformed<br>
Standard<br>
Instruction</th>
<th class="tableblock halign-center valign-bottom">Custom Value</th>
<th class="tableblock halign-center valign-bottom">Pseudoinstruction Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction address misaligned</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction access fault<br>
Illegal instruction<br>
Breakpoint<br>
Virtual instruction</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes<br>
Yes<br>
Yes<br>
Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No<br>
No<br>
No<br>
No<br></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No<br>
No<br>
Yes<br>
Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No<br>
No<br>
No<br>
No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Load address misaligned<br>
Load access fault<br>
Store/AMO address misaligned<br>
Store/AMO access fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes<br>
Yes<br>
Yes<br>
Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes<br>
Yes<br>
Yes<br>
Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes<br>
Yes<br>
Yes<br>
Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No<br>
No<br>
No<br>
No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Environment call</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction page fault<br>
Load page fault<br>
Store/AMO page fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes<br>
Yes<br>
Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No<br>
Yes<br>
Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No<br>
Yes<br>
Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No<br>
No<br>
No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction guest-page fault<br>
Load guest-page fault<br>
Store/AMO guest-page fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes<br>
Yes<br>
Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No<br>
Yes<br>
Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No<br>
Yes<br>
Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes<br>
Yes<br>
Yes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>As enumerated in the table, a synchronous exception may write to the
trap instruction register a standard transformation of the trapping
instruction only for exceptions that arise from explicit memory accesses
(from loads, stores, and AMO instructions). Accordingly, standard
transformations are currently defined only for these memory-access
instructions. If a synchronous trap occurs for a standard instruction
for which no transformation has been defined, the trap instruction
register shall be written with zero (or, under certain circumstances,
with a special pseudoinstruction value).</p>
</div>
<div class="paragraph">
<p>For a standard load instruction that is not a compressed instruction and
is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the
transformed instruction has the format shown in
<a href="#transformedloadinst">Transformed load instruction (LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same as the trapping load instruction.</a>.</p>
</div>
<div id="transformedloadinst" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDXUchLzE21UlDPL0jOT0lV11FILCkpAqpRN1ePrdVBqDSFqyxKQVJliqrKGK4qrTQvucQYSaUxLvMcU1KK9BT809KKU0twm4xQb4BbkTlWRRCfxOooJOfnpWUCAwDmWKPaWgDCBE9P?id=transformedloadinst" alt="Transformed load instruction (LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same as the trapping load instruction.">
</div>
<div class="title">Figure 42. Transformed load instruction (LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same as the trapping load instruction.</div>
</div>
<div class="paragraph">
<p>For a standard store instruction that is not a compressed instruction
and is one of SB, SH, SW, SD, FSW, FSD, FSQ, or FSH, the transformed
instruction has the format shown in
<a href="#transformedstoreinst">Transformed store instruction (SB, SH, SW, SD, FSW, FSD, FSQ, or FSH). Fields rs2, funct3, and opcode are the same as the trapping store instruction.</a>.</p>
</div>
<div id="transformedstoreinst" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDXUchLzE21UlDPL0jOT0lV11FILCkpAqpRN1ePrdVBqDSFqzRAUmSKqsgYriitNC-5xBhJpTEu4xxTUor0FPzT0opTS3CbjFBfVGyEW5k5VldCvBKro5Ccn5eWCQwBmHONamsB4PtPkA==?id=transformedstoreinst" alt="Transformed store instruction (SB, SH, SW, SD, FSW, FSD, FSQ, or FSH). Fields rs2, funct3, and opcode are the same as the trapping store instruction.">
</div>
<div class="title">Figure 43. Transformed store instruction (SB, SH, SW, SD, FSW, FSD, FSQ, or FSH). Fields rs2, funct3, and opcode are the same as the trapping store instruction.</div>
</div>
<div class="paragraph">
<p>For a standard atomic instruction (load-reserved, store-conditional, or AMO instruction), the transformed instruction has the format shown in <a href="#transformedatomicinst">Transformed atomic instruction (load-reserved, store-conditional, or AMO instruction). All fields are the same as the trapping instruction except bits 19:15, Addr. Offset.</a>.</p>
</div>
<div id="transformedatomicinst" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDXUchLzE21UlDPL0jOT0lV11FILCkpAqpRN1ePrdVBqDSFqyxKQVJliqrKGK4qrTQvucQYSaUxLvMcU1KK9BT809KKU0twm4xkf7ERbmWGCGU5SKoMcalKLMStyhTVM6YYtsbqKCTn56VlAsMU5n-j2loAbOxntw==?id=transformedatomicinst" alt="Transformed atomic instruction (load-reserved, store-conditional, or AMO instruction). All fields are the same as the trapping instruction except bits 19:15, Addr. Offset.">
</div>
<div class="title">Figure 44. Transformed atomic instruction (load-reserved, store-conditional, or AMO instruction). All fields are the same as the trapping instruction except bits 19:15, Addr. Offset.</div>
</div>
<div class="paragraph">
<p>For a standard virtual-machine load/store instruction (HLV, HLVX, or HSV), the transformed instruction has the format shown in <a href="#transformedvmaccessinst">Transformed virtual-machine load/store instruction (HLV, HLVX, HSV). All fields are the same as the trapping instruction except bits 19:15, Addr. Offset</a>.</p>
</div>
<div id="transformedvmaccessinst" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDXUchLzE21UlDPL0jOT0lV11FILCkpAqpRN1ePrdVBqDSFqyxKQVJliqrKGK4qrTQvucQYSaUxLvMcU1KK9BT809KKU0twm4xkf7ERbmXmqA4wx_BQrI5Ccn5eWiYwHGBuNqqtBQAsyFJd?id=transformedvmaccessinst" alt="Transformed virtual-machine load/store instruction (HLV, HLVX, HSV). All fields are the same as the trapping instruction except bits 19:15, Addr. Offset">
</div>
<div class="title">Figure 45. Transformed virtual-machine load/store instruction (HLV, HLVX, HSV). All fields are the same as the trapping instruction except bits 19:15, Addr. Offset</div>
</div>
<div class="paragraph">
<p>In all the transformed instructions above, the Addr.Â Offset field that
replaces the instructionâ€™s rs1 field in bits 19:15 is the positive
difference between the faulting virtual address (written to <code>mtval</code> or
<code>stval</code>) and the original virtual address. This difference can be
nonzero only for a misaligned memory access. Note also that, for basic
loads and stores, the transformations replace the instructionâ€™s
immediate offset fields with zero.</p>
</div>
<div class="paragraph">
<p>For a standard compressed instruction (16-bit size), the transformed
instruction is found as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Expand the compressed instruction to its 32-bit equivalent.</p>
</li>
<li>
<p>Transform the 32-bit equivalent instruction.</p>
</li>
<li>
<p>Replace bit 1 with a <code>0</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Bits 1:0 of a transformed standard instruction will be binary <code>01</code> if
the trapping instruction is compressed and <code>11</code> if not.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In decoding the contents of <code>mtinst</code> or <code>htinst</code>, once software has
determined that the register contains the encoding of a standard basic
load (LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic
store (SB, SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to
confirm also that the immediate offset fields (31:25, and 24:20 or 11:7)
are zeros. The knowledge that the registerâ€™s value is the encoding of a
basic load/store is sufficient to prove that the trapping instruction is
of the same kind.</p>
</div>
<div class="paragraph">
<p>A future version of this standard may add information to the fields that
are currently zeros. However, for backwards compatibility, any such
information will be for performance purposes only and can safely be
ignored.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For guest-page faults, the trap instruction register is written with a
special pseudoinstruction value if: (a) the fault is caused by an
implicit memory access for VS-stage address translation, and (b) a
nonzero value (the faulting guest physical address) is written to
<code>mtval2</code> or <code>htval</code>. If both conditions are met, the value written to
<code>mtinst</code> or <code>htinst</code> must be taken from
<a href="#pseudoinsts">Special pseudoinstruction values for guest-page faults.  The RV32 values are used when VSXLEN=32, and the RV64 values when VSXLEN=64.</a>; zero is not allowed.</p>
</div>
<table id="pseudoinsts" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 12. Special pseudoinstruction values for guest-page faults.  The RV32 values are used when VSXLEN=32, and the RV64 values when VSXLEN=64.</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Value</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x00002000</code><br>
<code>0x00002020</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32-bit read for VS-stage address translation (RV32)<br>
32-bit write for VS-stage address translation (RV32)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x00003000</code><br>
<code>0x00003020</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64-bit read for VS-stage address translation (RV64)<br>
64-bit write for VS-stage address translation (RV64)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The defined pseudoinstruction values are designed to correspond closely
with the encodings of basic loads and stores, as illustrated by
<a href="#pseudoinsts-basis">Standard instructions corresponding to the special pseudoinstructions of Special pseudoinstruction values for guest-page faults.  The RV32 values are used when VSXLEN=32, and the RV64 values when VSXLEN=64..</a>.</p>
</div>
<table id="pseudoinsts-basis" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 13. Standard instructions corresponding to the special pseudoinstructions of <a href="#pseudoinsts">Special pseudoinstruction values for guest-page faults.  The RV32 values are used when VSXLEN=32, and the RV64 values when VSXLEN=64.</a>.</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Encoding</th>
<th class="tableblock halign-left valign-top">Instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x00002003</code><br>
<code>0x00002023</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lw x0,0(x0)</code><br>
<code>sw x0,0(x0)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x00003003</code><br>
<code>0x00003023</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ld x0,0(x0)</code><br>
<code>sd x0,0(x0)</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A <em>write</em> pseudoinstruction (<code>0x00002020</code> or <code>0x00003020</code>) is used for
the case that the machine is attempting automatically to update bits A
and/or D in VS-level page tables. All other implicit memory accesses for
VS-stage address translation will be reads. If a machine never
automatically updates bits A or D in VS-level page tables (leaving this
to software), the <em>write</em> case will never arise. The fact that such a
page table update must actually be atomic, not just a simple write, is
ignored for the pseudoinstruction.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the conditions that necessitate a pseudoinstruction value can ever
occur for M-mode, then <code>mtinst</code> cannot be entirely read-only zero; and
likewise for HS-mode and <code>htinst</code>. However, in that case, the trap
instruction registers may minimally support only values 0 and
<code>0x00002000</code> or <code>0x00003000</code>, and possibly <code>0x00002020</code> or <code>0x00003020</code>,
requiring as few as one or two flip-flops in hardware, per register.</p>
</div>
<hr>
<div class="paragraph">
<p>There is no harm here in ignoring the atomicity requirement for page
table updates, because a hypervisor is not expected in these
circumstances to emulate an implicit memory access that fails. Rather,
the hypervisor is given enough information about the faulting access to
be able to make the memory accessible (e.g.Â by restoring a missing page
of virtual memory) before resuming execution by retrying the faulting
instruction.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="trap-return"><a class="anchor" href="#trap-return"></a>Trap Return</h4>
<div class="paragraph">
<p>The MRET instruction is used to return from a trap taken into M-mode.
MRET first determines what the new privilege mode will be according to
the values of MPP and MPV in <code>mstatus</code> or <code>mstatush</code>, as encoded in
<a href="#h-mpp">Value of <code>mstatus</code>/<code>mstatush</code> fields MPV and MPP after a trap into M-mode.  Upon trap return, MPV is ignored when MPP=3.</a>. MRET then in <code>mstatus</code>/<code>mstatush</code> sets
MPV=0, MPP=0, MIE=MPIE, and MPIE=1. Lastly, MRET sets the privilege mode
as previously determined, and sets <code>pc</code>=<code>mepc</code>.</p>
</div>
<div class="paragraph">
<p>The SRET instruction is used to return from a trap taken into HS-mode or
VS-mode. Its behavior depends on the current virtualization mode.</p>
</div>
<div class="paragraph">
<p>When executed in M-mode or HS-mode (i.e., V=0), SRET first determines
what the new privilege mode will be according to the values in
<code>hstatus</code>.SPV and <code>sstatus</code>.SPP, as encoded in
<a href="#h-spp">Value of <code>hstatus</code> field SPV and <code>sstatus</code> field SPP after a trap into HS-mode.</a>. SRET then sets <code>hstatus</code>.SPV=0, and in
<code>sstatus</code> sets SPP=0, SIE=SPIE, and SPIE=1. Lastly, SRET sets the
privilege mode as previously determined, and sets <code>pc</code>=<code>sepc</code>.</p>
</div>
<div class="paragraph">
<p>When executed in VS-mode (i.e., V=1), SRET sets the privilege mode
according to <a href="#h-vspp">Value of <code>vsstatus</code> field SPP after a trap into VS-mode.</a>, in <code>vsstatus</code> sets SPP=0,
SIE=SPIE, and SPIE=1, and lastly sets <code>pc</code>=<code>vsepc</code>.</p>
</div>
<div class="paragraph">
<p>If the Ssdbltrp extension is implemented, when <code>SRET</code> is executed in HS-mode,
if the new privilege mode is VU, the <code>SRET</code> instruction sets <code>vsstatus.SDT</code>
to 0. When executed in VS-mode, <code>vsstatus.SDT</code> is set to 0.</p>
</div>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="sscofpmf.html">"Sscofpmf" Extension for Count Overflow and Mode-Based Filtering, Version 1.0</a></span>
  <span class="next"><a href="priv-cfi.html">Control-flow Integrity(CFI)</a></span>
</nav>
</article>  </div>
</main>
<div class="modal micromodal-slide" id="modal-versions" aria-hidden="true">
    <div class="modal__overlay" tabindex="-1" data-micromodal-close>
        <div class="modal__container" role="dialog" aria-modal="true">
            <main class="modal__content" id="modal-versions-content">
              <button data-micromodal-close class="modal-versions-close">
                <svg width="28px" height="28px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><defs><style>.cls-1h{fill:none;stroke:#000;stroke-linecap:round;stroke-linejoin:round;stroke-width:2px;}</style></defs><title/><g id="cross"><line class="cls-1h" x1="7" x2="25" y1="7" y2="25"/><line class="cls-1h" x1="7" x2="25" y1="25" y2="7"/></g></svg>
              </button>
                  <ul class="nav-versions">
                      <li class="component">
                        <div>
                          <a class="title" href="../index.html">ISA Specifications</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../index.html">
      default
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                  </ul>
            </main>
        </div>
    </div>
</div>

</div>
<footer class="hidden">
		<script src="../../_/js/vendor/lunr.js"></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css"></script>
<script async src="../../search-index.js"></script>
</footer><script src="../../_/js/vendor/import.js"></script>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script async src="../../_/js/vendor/spring-tabs.js" data-sync-storage-key="docs:preferred-tab"></script>
  </body>
</html>
