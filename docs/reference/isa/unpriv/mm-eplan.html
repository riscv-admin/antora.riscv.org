<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: RISC-V Ratified Specifications Library</title>
    <link rel="prev" href="naming.html">
    <link rel="next" href="mm-formal.html">
    <meta name="generator" content="Antora 3.1.12">
    <script>
!function (theme, navWidth) {
  if (theme === 'dark') document.documentElement.classList.add('dark-theme')
  if (navWidth) document.documentElement.style.setProperty('--nav-width', `${navWidth}px`)
}(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: light)')?.matches && 'light'),
  localStorage && localStorage.getItem('nav-width'))
    </script>
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="stylesheet" href="../../_/css/vendor/search.css">
    <link rel="stylesheet" href="../../_/css/vendor/page-search.css">
    <link rel="stylesheet" href="../../_/css/vendor/spring-tabs.css">

    <meta name="antora-ui-version" content="1ea0d9f81bc80a15c1f560d76c5d8bddea1856e2"> 
    <meta name="version" content="">
    <meta name="component" content="isa">
    <meta name="latest-version" content="false">
    <link rel="icon" href="../../_/favicon.ico" type="image/x-icon">
  </head>
  <body class="article">


<header class="header" id="antora-header">
    <nav class="navbar">
        <head>
            <link data-rh="true" rel="icon" href="/img/favicon.ico">
            <link data-rh="true" rel="canonical" href="https://developer.riscv.org/ref">
            <link data-rh="true" rel="alternate" href="https://developer.riscv.org/ref" hreflang="en">
            <link data-rh="true" rel="alternate" href="https://developer.riscv.org/ref" hreflang="x-default">
            <link data-rh="true" rel="preconnect" href="https://MGVPU7BN22-dsn.algolia.net" crossorigin="anonymous">
            <link rel="stylesheet" type="text/css" href="/docs/reference/_/docusaurus-styles-copy-08-25.css">

        </head>
        <script>
            !function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())
        </script>
            <link rel="preload" as="image" href="/img/logo.svg">
            <div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div>
            <div class="announcementBar_mb4j" role="banner">
                <div class="announcementBarPlaceholder_vyr4"></div>
                <div class="content_knG7 announcementBarContent_xLdY">congratulations, you found the RISC-V Developer Portal! ðŸŽ‰ . This site is under active development and not meant for public consumption yet.</div><button type="button" aria-label="Close" class="clean-btn close closeButton_CVFx announcementBarClose_gvF7"><svg viewBox="0 0 15 15" width="14" height="14"><g stroke="currentColor" stroke-width="3.1"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div>
            <nav aria-label="Main" class="navbar ">
                <div class="navbar__inner">
                    <div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button>
                        <a class="navbar__brand" href="/">
                            <div class="navbar__logo"><img src="/img/logo.svg" alt="RISC-V Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="RISC-V Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Home</b></a>
                        <div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Specifications</a>
                            <ul class="dropdown__menu">
                                <li><a class="dropdown__link" href="/docs/spec/isa">ISA</a></li>
                                <li><a class="dropdown__link" href="/docs/spec/profiles">Profiles</a></li>
                                <li><a class="dropdown__link" docid="spec/non-isa" href="/docs/spec/non-isa">Non-ISA</a></li>
                            </ul>
                        </div>
                        <div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Developers</a>
                            <ul class="dropdown__menu">
                                <li><a class="dropdown__link" href="/docs/spec/intro">Specification Developers</a></li>
                                <li><a class="dropdown__link" href="/docs/hardware/overview">Hardware Developers</a></li>
                                <li><a class="dropdown__link" href="/docs/software/overview">Software Developers</a></li>
                            </ul>
                        </div><a class="navbar__item navbar__link" href="/blog">Blog</a><a href="https://riscv.org/community/calendar/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Events<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div>
                        <div class="navbar-item search hide-for-print">
                          <div id="search-field" class="field">
                            <input id="search-input" type="text" placeholder="Search">
                          </div>
                        </div>
                    <div class="navbar__items navbar__items--right">


                      <div class="navbarSearchContainer_Bca1">

                      </div>
                    </div>
                </div>
                <div role="presentation" class="navbar-sidebar__backdrop"></div>
            </nav>
            <div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper__tJE"></div>
        

    </nav>
</header><div class="body">
<div class="nav-container" data-component="isa" data-version="">
  <aside class="nav">
    <div class="panels">
      <div class="nav-panel-menu is-active" data-panel="menu">
        <nav class="nav-menu">
<div class="context">
  <span class="title">ISA Specifications</span>
  <span class="version">default</span>
  <button class="browse-version" id="browse-version">
    <svg
      height="24px"
      id="Layer_1"
      style="enable-background:new 0 0 512 512;"
      version="1.1"
      viewBox="0 0 512 512"
      width="24px"
      xml:space="preserve"
    ><g><path
          d="M256,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S273.7,224,256,224L256,224z"
        ></path><path
          d="M128.4,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S146,224,128.4,224L128.4,224z"
        ></path><path
          d="M384,224c-17.7,0-32,14.3-32,32s14.3,32,32,32s32-14.3,32-32S401.7,224,384,224L384,224z"
        ></path></g></svg>
  </button>
  </div><ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Volume I: RISC-V Unprivileged ISA Specification</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="colophon.html">Preface</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="rv32.html">RV32I Base Integer Instruction Set</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="rv32e.html">RV32E and RV64E Base Integer Instruction Sets, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="rv64.html">RV64I Base Integer Instruction Set</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zifencei.html">"Zifencei" Extension for Instruction-Fetch Fence, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zicsr.html">"Zicsr", Extension for Control and Status Register (CSR) Instructions, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="counters.html">"Zicntr" and "Zihpm" Extensions for Counters, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zihintntl.html">"Zihintntl" Extension for Non-Temporal Locality Hints, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zihintpause.html">"Zihintpause" Extension for Pause Hint, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zimop.html">"Zimop" Extension for May-Be-Operations, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zicond.html">"Zicond" Extension for Integer Conditional Operations, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="m-st-ext.html">"M" Extension for Integer Multiplication and Division, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="a-st-ext.html">"A" Extension for Atomic Instructions, Version 2.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zawrs.html">"Zawrs" Extension for Wait-on-Reservation-Set instructions, Version 1.01</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zacas.html">"Zacas" Extension for Atomic Compare-and-Swap (CAS) Instructions, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zabha.html">"Zabha" Extension for Byte and Halfword Atomic Memory Operations, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="rvwmo.html">RVWMO Memory Consistency Model, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="ztso-st-ext.html">"Ztso" Extension for Total Store Ordering, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="cmo.html">"CMO" Extensions for Base Cache Management Operation ISA, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="f-st-ext.html">"F" Extension for Single-Precision Floating-Point, Version 2.2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="d-st-ext.html">"D" Extension for Double-Precision Floating-Point, Version 2.2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="q-st-ext.html">"Q" Extension for Quad-Precision Floating-Point, Version 2.2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zfh.html">"Zfh" and "Zfhmin" Extensions for Half-Precision Floating-Point, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="bfloat16.html">"BF16" Extensions for for BFloat16-precision Floating-Point, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zfa.html">"Zfa" Extension for Additional Floating-Point Instructions, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zfinx.html">"Zfinx", "Zdinx", "Zhinx", "Zhinxmin" Extensions for Floating-Point in Integer Registers, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="c-st-ext.html">"C" Extension for Compressed Instructions, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="zc.html">"Zc*" Extension for Code Size Reduction, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="b-st-ext.html">"B" Extension for Bit Manipulation, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="v-st-ext.html">"V" Standard Extension for Vector Operations, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="scalar-crypto.html">Cryptography Extensions: Scalar &amp; Entropy Source Instructions, Version 1.0.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="vector-crypto.html">Cryptography Extensions: Vector Instructions, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="unpriv-cfi.html">Control-flow Integrity (CFI)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="rv-32-64g.html">RV32/64G Instruction Set Listings</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="naming.html">ISA Extension Naming Conventions</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link"  href="mm-eplan.html">Appendix A: RVWMO Explanatory Material, Version 0.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="mm-formal.html">Appendix B: Formal Memory Model Specifications, Version 0.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="vector-examples.html">Appendix C: Vector Assembly Code Examples</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="calling-convention.html">Appendix D: Calling Convention for Vector State (Not authoritative - Placeholder Only)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Volume II: RISC-V Privileged ISA Specification</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/priv-index.html">Privileged Architecture</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/priv-contributors.html">Contributors</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/priv-preface.html">Preface</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/priv-intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/priv-csrs.html">Control and Status Registers (CSRs)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/machine.html">Machine-Level ISA, Version 1.13</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/smstateen.html">"Smstateen/Ssstateen" Extensions, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/indirect-csr.html">"Smcsrind/Sscsrind" Indirect CSR Access, version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="#smepmp.adoc">"Smepmp" Extension for PMP Enhancements, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/smcntrpmf.html">"Smcntrpmf" Cycke and Instret Privilege Mode Filtering, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/rnmi.html">"Smrnmi" Extension for Resumable Non-Maskable Interrupts, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/smcdeleg.html">"Smcdeleg" Counter Delegation Extension, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/smdbltrp.html">"Smdbltrp" Double Trap Extension, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/smctr.html">"Smctr" Control Transfer Records Extension, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/supervisor.html">Supervisor-Level ISA, Version 1.13</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/sstc.html">"Sstc" Extension for Supervisor-mode Timer Interrupts, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/sscofpmf.html">"Sscofpmf" Extension for Count Overflow and Mode-Based Filtering, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/hypervisor.html">"H" Extension for Hypervisor Support, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/priv-cfi.html">Control-flow Integrity(CFI)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/ssdbltrp.html">"Ssdbltrp" Double Trap Extension, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/zpm.html">Pointer Masking Extensions, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/priv-insns.html">RISC-V Privileged Instruction Set Listings</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/priv-history.html">History</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="../priv/bibliography.html">Bibliography</a>
  </li>
</ul>
  </li>
</ul>
          <div class="toggle-sm">
            <button id="nav-toggle-2" class="nav-toggle"></button>
          </div>
        </nav>
      </div>
      <div class="nav-collapse">
        <button id="nav-collapse-toggle"><span></span></button>        
      </div>
    </div>
    <div class="nav-resize"></div>
  </aside>
</div>
<script>
!function (sidebar) {
  if (sidebar) {
    document.body.classList.add('nav-sm')
  }
}(localStorage && localStorage.getItem('sidebar') === 'close')
</script><main class="article">
<div class="toolbar" role="navigation">
  <button id="nav-toggle-1" class="nav-toggle"></button>
</div>
  <div class="content">
<aside class="sidebar">
  <div class="content">
    <div
      class="toc"
      data-title=""
      data-levels="2"
    >
      <div class="toc-menu"></div>
    </div>
    <div class="sidebar-links">
    </div>
  </div>
</aside>
<article class="doc">
<div class="breadcrumbs-container">
  <nav class="breadcrumbs" aria-label="breadcrumbs">
    <ul>
      <li><a href="../index.html">ISA Specifications</a></li>
      <li>Volume I: RISC-V Unprivileged ISA Specification</li>
      <li><a href="mm-eplan.html">Appendix A: RVWMO Explanatory Material, Version 0.1</a></li>
    </ul>
  </nav>
</div><div class="sect1">
<h2 id="rvwmo-explanatory-material-version-0-1"><a class="anchor" href="#rvwmo-explanatory-material-version-0-1"></a>Appendix A: RVWMO Explanatory Material, Version 0.1</h2>
<div class="sectionbody">
<div id="mm-explain" class="paragraph">
<p>This section provides more explanation for RVWMO
<a href="rvwmo.html" class="xref page">"RVWMO Memory Consistency Model</a>, using more informal
language and concrete examples. These are intended to clarify the
meaning and intent of the axioms and preserved program order rules. This
appendix should be treated as commentary; all normative material is
provided in <a href="rvwmo.html" class="xref page">"RVWMO Memory Consistency Model</a> and in the rest of
the main body of the ISA specification. All currently known
discrepancies are listed in <a href="#discrepancies">Known Issues</a>. Any
other discrepancies are unintentional.</p>
</div>
<div class="sect2">
<h3 id="whyrvwmo"><a class="anchor" href="#whyrvwmo"></a>Why RVWMO?</h3>
<div class="paragraph">
<p>Memory consistency models fall along a loose spectrum from weak to
strong. Weak memory models allow more hardware implementation
flexibility and deliver arguably better performance, performance per
watt, power, scalability, and hardware verification overheads than
strong models, at the expense of a more complex programming model.
Strong models provide simpler programming models, but at the cost of
imposing more restrictions on the kinds of (non-speculative) hardware
optimizations that can be performed in the pipeline and in the memory
system, and in turn imposing some cost in terms of power, area overhead,
and verification burden.</p>
</div>
<div class="paragraph">
<p>RISC-V has chosen the RVWMO memory model, a variant of release
consistency. This places it in between the two extremes of the memory
model spectrum. The RVWMO memory model enables architects to build
simple implementations, aggressive implementations, implementations
embedded deeply inside a much larger system and subject to complex
memory system interactions, or any number of other possibilities, all
while simultaneously being strong enough to support programming language
memory models at high performance.</p>
</div>
<div class="paragraph">
<p>To facilitate the porting of code from other architectures, some
hardware implementations may choose to implement the Ztso extension,
which provides stricter RVTSO ordering semantics by default. Code
written for RVWMO is automatically and inherently compatible with RVTSO,
but code written assuming RVTSO is not guaranteed to run correctly on
RVWMO implementations. In fact, most RVWMO implementations will (and
should) simply refuse to run RVTSO-only binaries. Each implementation
must therefore choose whether to prioritize compatibility with RVTSO
code (e.g., to facilitate porting from x86) or whether to instead
prioritize compatibility with other RISC-V cores implementing RVWMO.</p>
</div>
<div class="paragraph">
<p>Some fences and/or memory ordering annotations in code written for RVWMO
may become redundant under RVTSO; the cost that the default of RVWMO
imposes on Ztso implementations is the incremental overhead of fetching
those fences (e.g., FENCE R,RW and FENCE RW,W) which become no-ops on
that implementation. However, these fences must remain present in the
code if compatibility with non-Ztso implementations is desired.</p>
</div>
</div>
<div class="sect2">
<h3 id="litmustests"><a class="anchor" href="#litmustests"></a>Litmus Tests</h3>
<div class="paragraph">
<p>The explanations in this chapter make use of <em>litmus tests</em>, or small
programs designed to test or highlight one particular aspect of a memory
model. <a href="#litmus-sample">Litmus sample</a> shows an example
of a litmus test with two harts. As a convention for this figure and for
all figures that follow in this chapter, we assume that <code>s0-s2</code> are
pre-set to the same value in all harts and that <code>s0</code> holds the address
labeled <code>x</code>, <code>s1</code> holds <code>y</code>, and <code>s2</code> holds <code>z</code>, where <code>x</code>, <code>y</code>, and <code>z</code>
are disjoint memory locations aligned to 8 byte boundaries. All other registers and all referenced memory locations are presumed to be initialized to zero.  Each figure
shows the litmus test code on the left, and a visualization of one
particular valid or invalid execution on the right.</p>
</div>
<table id="litmus-sample" class="tableblock frame-none grid-none stretch center">
<caption class="title">Table 1. A sample litmus test and one forbidden execution (<code>a0=1</code>).</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><table class="tableblock frame-all grid-all fit-content center left">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Hart 0</th>
<th class="tableblock halign-left valign-top" colspan="2">Hart 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8942;</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8942;</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">li t1,1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">li t4,4</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s0)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(e)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t4,0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8942;</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8942;</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">li t2,2</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t2,0(s0)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8942;</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8942;</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(c)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a0,0(s0)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8942;</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8942;</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">li t3,3</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">li t5,5</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t3,0(s0)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(f)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t5,0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8942;</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8942;</p></td>
</tr>
</tbody>
</table></div></td>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="_images/graphviz/litmus_sample.png" alt="litmus sample"></span></p></td>
</tr>
</tbody>
</table></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Litmus tests are used to understand the implications of the memory model
in specific concrete situations. For example, in the litmus test of
<a href="#litmus-sample">Litmus sample</a>, the final value of <code>a0</code>
in the first hart can be either 2, 4, or 5, depending on the dynamic
interleaving of the instruction stream from each hart at runtime.
However, in this example, the final value of <code>a0</code> in Hart 0 will never
be 1 or 3; intuitively, the value 1 will no longer be visible at the
time the load executes, and the value 3 will not yet be visible by the
time the load executes. We analyze this test and many others below.</p>
</div>
<div style="page-break-after: always;"></div>
<table id="litmus-key" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 2. A key for the litmus test diagrams drawn in this appendix</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Edge</th>
<th class="tableblock halign-left valign-top">Full Name (and explanation)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reads From (from each store to the loads that return a value
written by that store)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">co</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Coherence (a total order on the stores to each address)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">From-Reads (from each load to co-successors of the store from which
the load returned a value)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ppo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Preserved Program Order</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fence</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Orderings enforced by a FENCE instruction</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">addr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Address Dependency</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ctrl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Control Dependency</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data Dependency</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The diagram shown to the right of each litmus test shows a visual
representation of the particular execution candidate being considered.
These diagrams use a notation that is common in the memory model
literature for constraining the set of possible global memory orders
that could produce the execution in question. It is also the basis for
the <em>herd</em> models presented in
<a href="#sec:herd">[sec:herd]</a>. This notation is explained in
<a href="#litmus-key">A key for the litmus test diagrams drawn in this appendix</a>. Of the listed relations, rf edges between
harts, co edges, fr edges, and ppo edges directly constrain the global
memory order (as do fence, addr, data, and some ctrl edges, via ppo).
Other edges (such as intra-hart rf edges) are informative but do not
constrain the global memory order.</p>
</div>
<div class="paragraph">
<p>For example, in <a href="#litmus-sample">Litmus sample</a>, <code>a0=1</code>
could occur only if one of the following were true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(b) appears before (a) in global memory order (and in the
coherence order co). However, this violates RVWMO PPO
rule <code>ppo:&#8594;st</code>. The co edge from (b) to (a) highlights this
contradiction.</p>
</li>
<li>
<p>(a) appears before (b) in global memory order (and in the
coherence order co). However, in this case, the Load Value Axiom would
be violated, because (a) is not the latest matching store prior to (c)
in program order. The fr edge from (c) to (b) highlights this
contradiction.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since neither of these scenarios satisfies the RVWMO axioms, the outcome
<code>a0=1</code> is forbidden.</p>
</div>
<div class="paragraph">
<p>Beyond what is described in this appendix, a suite of more than seven
thousand litmus tests is available at
<a href="https://github.com/litmus-tests/litmus-tests-riscv" class="bare">https://github.com/litmus-tests/litmus-tests-riscv</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The litmus tests repository also provides instructions on how to run the
litmus tests on RISC-V hardware and how to compare the results with the
operational and axiomatic models.</p>
</div>
<div class="paragraph">
<p>In the future, we expect to adapt these memory model litmus tests for
use as part of the RISC-V compliance test suite as well.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="explaining-the-rvwmo-rules"><a class="anchor" href="#explaining-the-rvwmo-rules"></a>Explaining the RVWMO Rules</h3>
<div class="paragraph">
<p>In this section, we provide explanation and examples for all of the
RVWMO rules and axioms.</p>
</div>
<div class="sect3">
<h4 id="preserved-program-order-and-global-memory-order"><a class="anchor" href="#preserved-program-order-and-global-memory-order"></a>Preserved Program Order and Global Memory Order</h4>
<div class="paragraph">
<p>Preserved program order represents the subset of program order that must
be respected within the global memory order. Conceptually, events from
the same hart that are ordered by preserved program order must appear in
that order from the perspective of other harts and/or observers. Events
from the same hart that are not ordered by preserved program order, on
the other hand, may appear reordered from the perspective of other harts
and/or observers.</p>
</div>
<div class="paragraph">
<p>Informally, the global memory order represents the order in which loads
and stores perform. The formal memory model literature has moved away
from specifications built around the concept of performing, but the idea
is still useful for building up informal intuition. A load is said to
have performed when its return value is determined. A store is said to
have performed not when it has executed inside the pipeline, but rather
only when its value has been propagated to globally visible memory. In
this sense, the global memory order also represents the contribution of
the coherence protocol and/or the rest of the memory system to
interleave the (possibly reordered) memory accesses being issued by each
hart into a single total order agreed upon by all harts.</p>
</div>
<div class="paragraph">
<p>The order in which loads perform does not always directly correspond to
the relative age of the values those two loads return. In particular, a
load <em>b</em> may perform before another load <em>a</em> to
the same address (i.e., <em>b</em> may execute before
<em>a</em>, and <em>b</em> may appear before <em>a</em>
in the global memory order), but <em>a</em> may nevertheless return
an older value than <em>b</em>. This discrepancy captures (among
other things) the reordering effects of buffering placed between the
core and memory. For example, <em>b</em> may have returned a value
from a store in the store buffer, while <em>a</em> may have ignored
that younger store and read an older value from memory instead. To
account for this, at the time each load performs, the value it returns
is determined by the load value axiom, not just strictly by determining
the most recent store to the same address in the global memory order, as
described below.</p>
</div>
</div>
<div class="sect3">
<h4 id="loadvalueaxiom"><a class="anchor" href="#loadvalueaxiom"></a>Load value axiom</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#ax-load">[ax-load]</a>: Each byte of each load <em>i</em> returns the value written
to that byte by the store that is the latest in global memory order among
the following stores:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Stores that write that byte and that precede i in the global memory
order</p>
</li>
<li>
<p>Stores that write that byte and that precede i in program order</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Preserved program order is <em>not</em> required to respect the ordering of a
store followed by a load to an overlapping address. This complexity
arises due to the ubiquity of store buffers in nearly all
implementations. Informally, the load may perform (return a value) by
forwarding from the store while the store is still in the store buffer,
and hence before the store itself performs (writes back to globally
visible memory). Any other hart will therefore observe the load as
performing before the store.</p>
</div>
<div class="paragraph">
<p>Consider the <a href="#litms_sb_forward">A store buffer forwarding litmus test (outcome permitted)</a>. When running this program on an implementation with
store buffers, it is possible to arrive at the final outcome <code>a0=1, a1=0, a2=1, a3=0</code> as follows:</p>
</div>
<table id="litms_sb_forward" class="tableblock frame-none grid-none stretch center">
<caption class="title">Table 3. A store buffer forwarding litmus test (outcome permitted)</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Hart 0</th>
<th class="tableblock halign-center valign-top" colspan="2">Hart 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t1, 1</p></td>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t1, 1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">(a) sw t1,0(s0)</p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">(e) sw t1,0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">(b) lw a0,0(s0)</p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">(f) lw a2,0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">(c) fence r,r</p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">(g) fence r,r</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">(d) lw a1,0(s1)</p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">(h) lw a3,0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">Outcome: <code>a0=1</code>, <code>a1=0</code>, <code>a2=1</code>, <code>a3=0</code></p></td>
</tr>
</tbody>
</table></div></td>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="_images/graphviz/litmus_sb_fwd.png" alt="litmus sb fwd"></span></p></td>
</tr>
</tbody>
</table></div></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p>(a) executes and enters the first hart&#8217;s private store buffer</p>
</li>
<li>
<p>(b) executes and forwards its return value 1 from (a) in the
store buffer</p>
</li>
<li>
<p>(c) executes since all previous loads (i.e., (b)) have
completed</p>
</li>
<li>
<p>(d) executes and reads the value 0 from memory</p>
</li>
<li>
<p>(e) executes and enters the second hart&#8217;s private store buffer</p>
</li>
<li>
<p>(f) executes and forwards its return value 1 from (e) in the
store buffer</p>
</li>
<li>
<p>(g) executes since all previous loads (i.e., (f)) have
completed</p>
</li>
<li>
<p>(h) executes and reads the value 0 from memory</p>
</li>
<li>
<p>(a) drains from the first hart&#8217;s store buffer to memory</p>
</li>
<li>
<p>(e) drains from the second hart&#8217;s store buffer to memory</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Therefore, the memory model must be able to account for this behavior.</p>
</div>
<div class="paragraph">
<p>To put it another way, suppose the definition of preserved program order
did include the following hypothetical rule: memory access
<em>a</em> precedes memory access <em>b</em> in preserved
program order (and hence also in the global memory order) if
<em>a</em> precedes <em>b</em> in program order and
<em>a</em> and <em>b</em> are accesses to the same memory
location, <em>a</em> is a write, and <em>b</em> is a read.
Call this "Rule X". Then we get the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(a) precedes (b): by rule X</p>
</li>
<li>
<p>(b) precedes (d): by rule <a href="#overlapping-ordering">4</a></p>
</li>
<li>
<p>(d) precedes (e): by the load value axiom. Otherwise, if (e)
preceded (d), then (d) would be required to return the value 1. (This is
a perfectly legal execution; it&#8217;s just not the one in question)</p>
</li>
<li>
<p>(e) precedes (f): by rule X</p>
</li>
<li>
<p>(f) precedes (h): by rule <a href="#overlapping-ordering">4</a></p>
</li>
<li>
<p>(h) precedes (a): by the load value axiom, as above.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The global memory order must be a total order and cannot be cyclic,
because a cycle would imply that every event in the cycle happens before
itself, which is impossible. Therefore, the execution proposed above
would be forbidden, and hence the addition of rule X would forbid
implementations with store buffer forwarding, which would clearly be
undesirable.</p>
</div>
<div class="paragraph">
<p>Nevertheless, even if (b) precedes (a) and/or (f) precedes (e) in the
global memory order, the only sensible possibility in this example is
for (b) to return the value written by (a), and likewise for (f) and
(e). This combination of circumstances is what leads to the second
option in the definition of the load value axiom. Even though (b)
precedes (a) in the global memory order, (a) will still be visible to
(b) by virtue of sitting in the store buffer at the time (b) executes.
Therefore, even if (b) precedes (a) in the global memory order, (b)
should return the value written by (a) because (a) precedes (b) in
program order. Likewise for (e) and (f).</p>
</div>
<table id="litmus_ppoca" class="tableblock frame-none grid-none stretch center">
<caption class="title">Table 4. The "PPOCA" store buffer forwarding litmus test (outcome permitted)</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Hart 0</th>
<th class="tableblock halign-center valign-top" colspan="2">Hart 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">li t1, 1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">li t1, 1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s0)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOOP:</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fence w,w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a0,0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(c)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s1)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">beqz a0, LOOP</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(e)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">sw t1,0(s2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(f)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">lw a1,0(s2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">xor a2,a1,a1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">add s0,s0,a2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(g)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">lw a2,0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">Outcome: <code>a0=1</code>, <code>a1=1</code>, <code>a2=0</code></p></td>
</tr>
</tbody>
</table></div></td>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="_images/graphviz/litmus_ppoca.png" alt="litmus ppoca"></span></p></td>
</tr>
</tbody>
</table></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Another test that highlights the behavior of store buffers is shown in
<a href="#litmus_ppoca">The "PPOCA" store buffer forwarding litmus test (outcome permitted)</a>. In this example, (d) is
ordered before (e) because of the control dependency, and (f) is ordered
before (g) because of the address dependency. However, (e) is <em>not</em>
necessarily ordered before (f), even though (f) returns the value
written by (e). This could correspond to the following sequence of
events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(e) executes speculatively and enters the second hart&#8217;s private
store buffer (but does not drain to memory)</p>
</li>
<li>
<p>(f) executes speculatively and forwards its return value 1 from
(e) in the store buffer</p>
</li>
<li>
<p>(g) executes speculatively and reads the value 0 from memory</p>
</li>
<li>
<p>(a) executes, enters the first hart&#8217;s private store buffer, and
drains to memory</p>
</li>
<li>
<p>(b) executes and retires</p>
</li>
<li>
<p>(c) executes, enters the first hart&#8217;s private store buffer, and
drains to memory</p>
</li>
<li>
<p>(d) executes and reads the value 1 from memory</p>
</li>
<li>
<p>(e), (f), and (g) commit, since the speculation turned out to be
correct</p>
</li>
<li>
<p>(e) drains from the store buffer to memory</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="atomicityaxiom"><a class="anchor" href="#atomicityaxiom"></a>Atomicity axiom</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#ax-atom">Atomicity Axiom</a> (for Aligned Atomics): If r and w are paired load and
store operations generated by aligned LR and SC instructions in a hart
h, s is a store to byte x, and r returns a value written by s, then s must
precede w in the global memory order, and there can be no store from
a hart other than h to byte x following s and preceding w in the global
memory order.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The RISC-V architecture decouples the notion of atomicity from the
notion of ordering. Unlike architectures such as TSO, RISC-V atomics
under RVWMO do not impose any ordering requirements by default. Ordering
semantics are only guaranteed by the PPO rules that otherwise apply.</p>
</div>
<div class="paragraph">
<p>RISC-V contains two types of atomics: AMOs and LR/SC pairs. These
conceptually behave differently, in the following way. LR/SC behave as
if the old value is brought up to the core, modified, and written back
to memory, all while a reservation is held on that memory location. AMOs
on the other hand conceptually behave as if they are performed directly
in memory. AMOs are therefore inherently atomic, while LR/SC pairs are
atomic in the slightly different sense that the memory location in
question will not be modified by another hart during the time the
original hart holds the reservation.</p>
</div>
<table id="litmus_lrsdsc" class="tableblock frame-none grid-all stretch">
<caption class="title">Table 5. In all four (independent) instances, the final  store-conditional instruction is permitted but not guaranteed to succeed.</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">(a) lr.d a0, 0(s0)</th>
<th class="tableblock halign-left valign-top">(a) lr.d a0, 0(s0)</th>
<th class="tableblock halign-left valign-top">(a) lr.w a0, 0(s0)</th>
<th class="tableblock halign-left valign-top">(a) lr.w a0, 0(s0)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(b) sd t1, 0(s0)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(b) sw t1, 4(s0)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(b) sw t1, 4(s0)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(b) sw t1, 4(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(c) sc.d t3, t2, 0(s0)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(c) sc.d t3, t2, 0(s0)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(c) sc.w t3, t2, 0(s0)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(c) addi s0, s0, 8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(d) sc.w t3, t2, 0(s0)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The atomicity axiom forbids stores from other harts from being
interleaved in global memory order between an LR and the SC paired with
that LR. The atomicity axiom does not forbid loads from being
interleaved between the paired operations in program order or in the
global memory order, nor does it forbid stores from the same hart or
stores to non-overlapping locations from appearing between the paired
operations in either program order or in the global memory order. For
example, the SC instructions in <a href="#litmus_lrsdsc">In all four (independent) instances, the final  store-conditional instruction is permitted but not guaranteed to succeed.</a> may (but are not
guaranteed to) succeed. None of those successes would violate the
atomicity axiom, because the intervening non-conditional stores are from
the same hart as the paired load-reserved and store-conditional
instructions. This way, a memory system that tracks memory accesses at
cache line granularity (and which therefore will see the four snippets
of <a href="#litmus_lrsdsc">In all four (independent) instances, the final  store-conditional instruction is permitted but not guaranteed to succeed.</a> as identical) will not
be forced to fail a store-conditional instruction that happens to
(falsely) share another portion of the same cache line as the memory
location being held by the reservation.</p>
</div>
<div class="paragraph">
<p>The atomicity axiom also technically supports cases in which the LR and
SC touch different addresses and/or use different access sizes; however,
use cases for such behaviors are expected to be rare in practice.
Likewise, scenarios in which stores from the same hart between an LR/SC
pair actually overlap the memory location(s) referenced by the LR or SC
are expected to be rare compared to scenarios where the intervening
store may simply fall onto the same cache line.</p>
</div>
</div>
<div class="sect3">
<h4 id="mm-progress"><a class="anchor" href="#mm-progress"></a>Progress axiom</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#ax-prog">Progress Axiom</a>: No memory operation may be preceded in the global
memory order by an infinite sequence of other memory operations.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The progress axiom ensures a minimal forward progress guarantee. It
ensures that stores from one hart will eventually be made visible to
other harts in the system in a finite amount of time, and that loads
from other harts will eventually be able to read those values (or
successors thereof). Without this rule, it would be legal, for example,
for a spinlock to spin infinitely on a value, even with a store from
another hart waiting to unlock the spinlock.</p>
</div>
<div class="paragraph">
<p>The progress axiom is intended not to impose any other notion of
fairness, latency, or quality of service onto the harts in a RISC-V
implementation. Any stronger notions of fairness are up to the rest of
the ISA and/or up to the platform and/or device to define and implement.</p>
</div>
<div class="paragraph">
<p>The forward progress axiom will in almost all cases be naturally
satisfied by any standard cache coherence protocol. Implementations with
non-coherent caches may have to provide some other mechanism to ensure
the eventual visibility of all stores (or successors thereof) to all
harts.</p>
</div>
</div>
<div class="sect3">
<h4 id="mm-overlap"><a class="anchor" href="#mm-overlap"></a>Overlapping-Address Orderings (<a href="#overlapping-ordering">Rules 1-3</a>)</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#overlapping-ordering">Rule 1</a>: b is a store, and a and b access overlapping memory addresses</p>
</div>
<div class="paragraph">
<p><a href="#overlapping-ordering">Rule 2</a>: a and b are loads, x is a byte read by both a and b, there is no
store to x between a and b in program order, and a and b return values
for x written by different memory operations</p>
</div>
<div class="paragraph">
<p><a href="#overlapping-ordering">Rule 3</a>: a is generated by an AMO or SC instruction, b is a load, and b
returns a value written by a</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Same-address orderings where the latter is a store are straightforward:
a load or store can never be reordered with a later store to an
overlapping memory location. From a microarchitecture perspective,
generally speaking, it is difficult or impossible to undo a
speculatively reordered store if the speculation turns out to be
invalid, so such behavior is simply disallowed by the model.
Same-address orderings from a store to a later load, on the other hand,
do not need to be enforced. As discussed in
<a href="#loadvalueaxiom">Load value axiom</a>, this reflects the observable
behavior of implementations that forward values from buffered stores to
later loads.</p>
</div>
<div class="paragraph">
<p>Same-address load-load ordering requirements are far more subtle. The
basic requirement is that a younger load must not return a value that is
older than a value returned by an older load in the same hart to the
same address. This is often known as "CoRR" (Coherence for Read-Read
pairs), or as part of a broader "coherence" or "sequential
consistency per location" requirement. Some architectures in the past
have relaxed same-address load-load ordering, but in hindsight this is
generally considered to complicate the programming model too much, and
so RVWMO requires CoRR ordering to be enforced. However, because the
global memory order corresponds to the order in which loads perform
rather than the ordering of the values being returned, capturing CoRR
requirements in terms of the global memory order requires a bit of
indirection.</p>
</div>
<table id="frirfi" class="tableblock frame-none grid-none stretch center">
<caption class="title">Table 6. Litmus test MP+fence.w.w+fre-rfi-addr (outcome permitted)</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Hart 0</th>
<th class="tableblock halign-center valign-top" colspan="2">Hart 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">li t1, 1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">li t2, 2</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s0)</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a0,0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fence w, w</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(e)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t2,0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">(c)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s1)</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(f)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a1,0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(g)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xor t3,a1,a1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(h)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">add s0,s0,t3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(i)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a2,0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">Outcome: <code>a0=1</code>, <code>a1=2</code>, <code>a2=0</code></p></td>
</tr>
</tbody>
</table></div></td>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="_images/graphviz/litmus_mp_fenceww_fri_rfi_addr.png" alt="litmus mp fenceww fri rfi addr"></span></p></td>
</tr>
</tbody>
</table></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Consider the litmus test of <a href="#frirfi">Litmus test MP+fence.w.w+fre-rfi-addr (outcome permitted)</a>, which is one particular
instance of the more general "fri-rfi" pattern. The term "fri-rfi"
refers to the sequence (d), (e), (f): (d) "from-reads" (i.e., reads
from an earlier write than) (e) which is the same hart, and (f) reads
from (e) which is in the same hart.</p>
</div>
<div class="paragraph">
<p>From a microarchitectural perspective, outcome <code>a0=1</code>, <code>a1=2</code>, <code>a2=0</code> is
legal (as are various other less subtle outcomes). Intuitively, the
following would produce the outcome in question:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(d) stalls (for whatever reason; perhaps it&#8217;s stalled waiting
for some other preceding instruction)</p>
</li>
<li>
<p>(e) executes and enters the store buffer (but does not yet
drain to memory)</p>
</li>
<li>
<p>(f) executes and forwards from (e) in the store buffer</p>
</li>
<li>
<p>(g), (h), and (i) execute</p>
</li>
<li>
<p>(a) executes and drains to memory, (b) executes, and (c)
executes and drains to memory</p>
</li>
<li>
<p>(d) unstalls and executes</p>
</li>
<li>
<p>(e) drains from the store buffer to memory</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This corresponds to a global memory order of (f), (i), (a), (c), (d),
(e). Note that even though (f) performs before (d), the value returned
by (f) is newer than the value returned by (d). Therefore, this
execution is legal and does not violate the CoRR requirements.</p>
</div>
<div class="paragraph">
<p>Likewise, if two back-to-back loads return the values written by the
same store, then they may also appear out-of-order in the global memory
order without violating CoRR. Note that this is not the same as saying
that the two loads return the same value, since two different stores may
write the same value.</p>
</div>
<table id="litmus-rsw" class="tableblock frame-none grid-none stretch center">
<caption class="title">Table 7. Litmus test RSW (outcome permitted)</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Hart 0</th>
<th class="tableblock halign-center valign-top" colspan="2">Hart 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t1, 1</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw  a0,0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s0)</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(e)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xor t2,a0,a0</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fence w, w</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(f)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">add s4,s2,t2</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">(c)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s1)</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(g)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw  a1,0(s4)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(h)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw  a2,0(s2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(i)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xor t3,a2,a2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(j)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">add s0,s0,t3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">(k)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw  a3,0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">Outcome: <code>a0=1</code>, <code>a1=v</code>, <code>a2=v</code>, <code>a3=0</code></p></td>
</tr>
</tbody>
</table></div></td>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="_images/graphviz/litmus_rsw.png" alt="litmus rsw"></span></p></td>
</tr>
</tbody>
</table></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Consider the litmus test of <a href="#litmus-rsw">Litmus test RSW (outcome permitted)</a>.
The outcome <code>a0=1</code>, <code>a1=v</code>, <code>a2=v</code>, <code>a3=0</code> (where <em>v</em> is
some value written by another hart) can be observed by allowing (g) and
(h) to be reordered. This might be done speculatively, and the
speculation can be justified by the microarchitecture (e.g., by snooping
for cache invalidations and finding none) because replaying (h) after
(g) would return the value written by the same store anyway. Hence
assuming <code>a1</code> and <code>a2</code> would end up with the same value written by the
same store anyway, (g) and (h) can be legally reordered. The global
memory order corresponding to this execution would be
(h),(k),(a),(c),(d),(g).</p>
</div>
<div class="paragraph">
<p>Executions of the test in <a href="#litmus-rsw">Litmus test RSW (outcome permitted)</a> in
which <code>a1</code> does not equal <code>a2</code> do in fact require that (g) appears
before (h) in the global memory order. Allowing (h) to appear before (g)
in the global memory order would in that case result in a violation of
CoRR, because then (h) would return an older value than that returned by
(g). Therefore, <a href="#overlapping-ordering">rule 2</a> forbids this CoRR violation
from occurring. As such, <a href="#overlapping-ordering">rule 2</a> strikes a careful
balance between enforcing CoRR in all cases while simultaneously being
weak enough to permit "RSW" and "fri-rfi" patterns that commonly
appear in real microarchitectures.</p>
</div>
<div class="paragraph">
<p>There is one more overlapping-address rule: <a href="#overlapping-ordering">rule 3</a> simply states that a value cannot
be returned from an AMO or SC to a subsequent load until the AMO or SC
has (in the case of the SC, successfully) performed globally. This
follows somewhat naturally from the conceptual view that both AMOs and
SC instructions are meant to be performed atomically in memory. However,
notably, <a href="#overlapping-ordering">rule 3</a> states that hardware
may not even non-speculatively forward the value being stored by an
AMOSWAP to a subsequent load, even though for AMOSWAP that store value
is not actually semantically dependent on the previous value in memory,
as is the case for the other AMOs. The same holds true even when
forwarding from SC store values that are not semantically dependent on
the value returned by the paired LR.</p>
</div>
<div class="paragraph">
<p>The three PPO rules above also apply when the memory accesses in
question only overlap partially. This can occur, for example, when
accesses of different sizes are used to access the same object. Note
also that the base addresses of two overlapping memory operations need
not necessarily be the same for two memory accesses to overlap. When
misaligned memory accesses are being used, the overlapping-address PPO
rules apply to each of the component memory accesses independently.</p>
</div>
</div>
<div class="sect3">
<h4 id="mm-fence"><a class="anchor" href="#mm-fence"></a>Fences (<a href="#overlapping-ordering">Rule 4</a>)</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Rule <a href="#overlapping-ordering">4</a>: There is a FENCE instruction that orders a before b</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, the FENCE instruction ensures that all memory accesses from
instructions preceding the fence in program order (the "predecessor
set") appear earlier in the global memory order than memory accesses
from instructions appearing after the fence in program order (the
"successor set"). However, fences can optionally further restrict the
predecessor set and/or the successor set to a smaller set of memory
accesses in order to provide some speedup. Specifically, fences have PR,
PW, SR, and SW bits which restrict the predecessor and/or successor
sets. The predecessor set includes loads (resp.stores) if and only if PR
(resp.PW) is set. Similarly, the successor set includes loads
(resp.stores) if and only if SR (resp.SW) is set.</p>
</div>
<div class="paragraph">
<p>The FENCE encoding currently has nine non-trivial combinations of the
four bits PR, PW, SR, and SW, plus one extra encoding FENCE.TSO which
facilitates mapping of "acquire+release" or RVTSO semantics. The
remaining seven combinations have empty predecessor and/or successor
sets and hence are no-ops. Of the ten non-trivial options, only six are
commonly used in practice:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>FENCE RW,RW</p>
</li>
<li>
<p>FENCE.TSO</p>
</li>
<li>
<p>FENCE RW,W</p>
</li>
<li>
<p>FENCE R,RW</p>
</li>
<li>
<p>FENCE R,R</p>
</li>
<li>
<p>FENCE W,W</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>FENCE instructions using any other combination of PR, PW, SR, and SW are
reserved. We strongly recommend that programmers stick to these six.
Other combinations may have unknown or unexpected interactions with the
memory model.</p>
</div>
<div class="paragraph">
<p>Finally, we note that since RISC-V uses a multi-copy atomic memory
model, programmers can reason about fences bits in a thread-local
manner. Fences in RISC-V are not cumulative, as they are in some
non-multi-copy-atomic memory models.</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:memory:acqrel"><a class="anchor" href="#sec:memory:acqrel"></a>Explicit Synchronization (<a href="#overlapping-ordering">Rules 5-8</a>)</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#overlapping-ordering">Rule 5</a>: a has an acquire annotation</p>
</div>
<div class="paragraph">
<p><a href="#overlapping-ordering">Rule 6</a>: b has a release annotation</p>
</div>
<div class="paragraph">
<p><a href="#overlapping-ordering">Rule 7</a>: a and b both have RCsc annotations</p>
</div>
<div class="paragraph">
<p><a href="#overlapping-ordering">Rule 8</a>: a is paired with b</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An <em>acquire</em> operation, as would be used at the start of a critical
section, requires all memory operations following the acquire in program
order to also follow the acquire in the global memory order. This
ensures, for example, that all loads and stores inside the critical
section are up to date with respect to the synchronization variable
being used to protect it. Acquire ordering can be enforced in one of two
ways: with an acquire annotation, which enforces ordering with respect
to just the synchronization variable itself, or with a FENCE R,RW, which
enforces ordering with respect to all previous loads.</p>
</div>
<div id="spinlock_atomics" class="listingblock">
<div class="title">A spinlock with atomics</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-asm hljs" data-lang="asm">          sd           x1, (a1)     # Arbitrary unrelated store
          ld           x2, (a2)     # Arbitrary unrelated load
          li           t0, 1        # Initialize swap value.
      again:
          amoswap.w.aq t0, t0, (a0) # Attempt to acquire lock.
          bnez         t0, again    # Retry if held.
          # ...
          # Critical section.
          # ...
          amoswap.w.rl x0, x0, (a0) # Release lock by storing 0.
          sd           x3, (a3)     # Arbitrary unrelated store
          ld           x4, (a4)     # Arbitrary unrelated load</code></pre>
</div>
</div>
<div class="paragraph">
<p>Consider <a href="#spinlock_atomics">Example 1</a>.
Because this example uses <em>aq</em>, the loads and stores in the critical
section are guaranteed to appear in the global memory order after the
AMOSWAP used to acquire the lock. However, assuming <code>a0</code>, <code>a1</code>, and <code>a2</code>
point to different memory locations, the loads and stores in the
critical section may or may not appear after the "Arbitrary unrelated
load" at the beginning of the example in the global memory order.</p>
</div>
<div id="spinlock_fences" class="listingblock">
<div class="title">A spinlock with fences</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-asm hljs" data-lang="asm">          sd           x1, (a1)     # Arbitrary unrelated store
          ld           x2, (a2)     # Arbitrary unrelated load
          li           t0, 1        # Initialize swap value.
      again:
          amoswap.w    t0, t0, (a0) # Attempt to acquire lock.
          fence        r, rw        # Enforce "acquire" memory ordering
          bnez         t0, again    # Retry if held.
          # ...
          # Critical section.
          # ...
          fence        rw, w        # Enforce "release" memory ordering
          amoswap.w    x0, x0, (a0) # Release lock by storing 0.
          sd           x3, (a3)     # Arbitrary unrelated store
          ld           x4, (a4)     # Arbitrary unrelated load</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, consider the alternative in <a href="#spinlock_fences">Example 2</a>. In
this case, even though the AMOSWAP does not enforce ordering with an
<em>aq</em> bit, the fence nevertheless enforces that the acquire AMOSWAP
appears earlier in the global memory order than all loads and stores in
the critical section. Note, however, that in this case, the fence also
enforces additional orderings: it also requires that the "Arbitrary
unrelated load" at the start of the program appears earlier in the
global memory order than the loads and stores of the critical section.
(This particular fence does not, however, enforce any ordering with
respect to the "Arbitrary unrelated store" at the start of the
snippet.) In this way, fence-enforced orderings are slightly coarser
than orderings enforced by <em>.aq</em>.</p>
</div>
<div class="paragraph">
<p>Release orderings work exactly the same as acquire orderings, just in
the opposite direction. Release semantics require all loads and stores
preceding the release operation in program order to also precede the
release operation in the global memory order. This ensures, for example,
that memory accesses in a critical section appear before the
lock-releasing store in the global memory order. Just as for acquire
semantics, release semantics can be enforced using release annotations
or with a FENCE RW,W operation. Using the same examples, the ordering
between the loads and stores in the critical section and the "Arbitrary
unrelated store" at the end of the code snippet is enforced only by the
FENCE RW,W in <a href="#spinlock_fences">Example 2</a>, not by
the <em>rl</em> in <a href="#spinlock_atomics">Example 1</a>.</p>
</div>
<div class="paragraph">
<p>With RCpc annotations alone, store-release-to-load-acquire ordering is
not enforced. This facilitates the porting of code written under the TSO
and/or RCpc memory models. To enforce store-release-to-load-acquire
ordering, the code must use store-release-RCsc and load-acquire-RCsc
operations so that PPO rule 7 applies. RCpc alone is
sufficient for many use cases in C/C++ but is insufficient for many
other use cases in C/C++, Java, and Linux, to name just a few examples;
see <a href="#memory_porting">Memory Porting</a> for details.</p>
</div>
<div class="paragraph">
<p>PPO rule 8 indicates that an SC must appear after
its paired LR in the global memory order. This will follow naturally
from the common use of LR/SC to perform an atomic read-modify-write
operation due to the inherent data dependency. However, PPO
rule 8 also applies even when the value being stored
does not syntactically depend on the value returned by the paired LR.</p>
</div>
<div class="paragraph">
<p>Lastly, we note that, as with fences, ordering annotations are
not cumulative.</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:memory:dependencies"><a class="anchor" href="#sec:memory:dependencies"></a>Syntactic Dependencies (<a href="#overlapping-ordering">Rules 9-11</a>)</h4>
<div id="ppo-addr" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#overlapping-ordering">Rule 9</a>: b has a syntactic address dependency on a</p>
</div>
<div class="paragraph">
<p><a href="#overlapping-ordering">Rule 10</a>: b has a syntactic data dependency on a</p>
</div>
<div class="paragraph">
<p><a href="#overlapping-ordering">Rule 11</a>: b is a store, and b has a syntactic control dependency on a</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Dependencies from a load to a later memory operation in the same hart
are respected by the RVWMO memory model. The Alpha memory model was
notable for choosing <em>not</em> to enforce the ordering of such dependencies,
but most modern hardware and software memory models consider allowing
dependent instructions to be reordered too confusing and
counterintuitive. Furthermore, modern code sometimes intentionally uses
such dependencies as a particularly lightweight ordering enforcement
mechanism.</p>
</div>
<div class="paragraph">
<p>The terms in <a href="#mem-dependencies">[mem-dependencies]</a> work as follows. Instructions
are said to carry dependencies from their
source register(s) to their destination register(s) whenever the value
written into each destination register is a function of the source
register(s). For most instructions, this means that the destination
register(s) carry a dependency from all source register(s). However,
there are a few notable exceptions. In the case of memory instructions,
the value written into the destination register ultimately comes from
the memory system rather than from the source register(s) directly, and
so this breaks the chain of dependencies carried from the source
register(s). In the case of unconditional jumps, the value written into
the destination register comes from the current <code>pc</code> (which is never
considered a source register by the memory model), and so likewise, JALR
(the only jump with a source register) does not carry a dependency from
<em>rs1</em> to <em>rd</em>.</p>
</div>
<div id="fflags" class="listingblock text-center">
<div class="title">(c) has a syntactic dependency on both (a) and (b) via fflags, a destination register that both (a) and (b) implicitly accumulate into</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-source%linenums hljs" data-lang="source%linenums">(a) fadd f3,f1,f2
(b) fadd f6,f4,f5
(c) csrrs a0,fflags,x0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The notion of accumulating into a destination register rather than
writing into it reflects the behavior of CSRs such as <code>fflags</code>. In
particular, an accumulation into a register does not clobber any
previous writes or accumulations into the same register. For example, in
<a href="#fflags">(c) has a syntactic dependency on both (a) and (b) via fflags, a destination register that both (a) and (b) implicitly accumulate into</a>, (c) has a syntactic dependency on both (a) and (b).</p>
</div>
<div class="paragraph">
<p>Like other modern memory models, the RVWMO memory model uses syntactic
rather than semantic dependencies. In other words, this definition
depends on the identities of the registers being accessed by different
instructions, not the actual contents of those registers. This means
that an address, control, or data dependency must be enforced even if
the calculation could seemingly be <code>optimized away</code>. This choice
ensures that RVWMO remains compatible with code that uses these false
syntactic dependencies as a lightweight ordering mechanism.</p>
</div>
<div id="address" class="listingblock text-center">
<div class="title">A syntactic address dependency</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-source%linenums hljs" data-lang="source%linenums">ld a1,0(s0)
xor a2,a1,a1
add s1,s1,a2
ld a5,0(s1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, there is a syntactic address dependency from the memory
operation generated by the first instruction to the memory operation
generated by the last instruction in
<a href="#address">A syntactic address dependency</a>, even though <code>a1</code> XOR
<code>a1</code> is zero and hence has no effect on the address accessed by the
second load.</p>
</div>
<div class="paragraph">
<p>The benefit of using dependencies as a lightweight synchronization
mechanism is that the ordering enforcement requirement is limited only
to the specific two instructions in question. Other non-dependent
instructions may be freely reordered by aggressive implementations. One
alternative would be to use a load-acquire, but this would enforce
ordering for the first load with respect to <em>all</em> subsequent
instructions. Another would be to use a FENCE R,R, but this would
include all previous and all subsequent loads, making this option more
expensive.</p>
</div>
<div id="control1" class="listingblock text-center">
<div class="title">A syntactic control dependency</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-source%linenums hljs" data-lang="source%linenums">lw x1,0(x2)
bne x1,x0,next
sw x3,0(x4)
next: sw x5,0(x6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Control dependencies behave differently from address and data
dependencies in the sense that a control dependency always extends to
all instructions following the original target in program order.
Consider <a href="#control1">A syntactic control dependency</a> the
instruction at <code>next</code> will always execute, but the memory operation
generated by that last instruction nevertheless still has a control
dependency from the memory operation generated by the first instruction.</p>
</div>
<div id="control2" class="listingblock text-center">
<div class="title">Another syntactic control dependency</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-source%linenums hljs" data-lang="source%linenums">lw x1,0(x2)
bne x1,x0,next
next: sw x3,0(x4)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Likewise, consider <a href="#control2">Another syntactic control dependency</a>.
Even though both branch outcomes have the same target, there is still a
control dependency from the memory operation generated by the first
instruction in this snippet to the memory operation generated by the
last instruction. This definition of control dependency is subtly
stronger than what might be seen in other contexts (e.g., C++), but it
conforms with standard definitions of control dependencies in the
literature.</p>
</div>
<div class="paragraph">
<p>Notably, PPO rules <a href="#overlapping-ordering">9-11</a> are also
intentionally designed to respect dependencies that originate from the
output of a successful store-conditional instruction. Typically, an SC
instruction will be followed by a conditional branch checking whether
the outcome was successful; this implies that there will be a control
dependency from the store operation generated by the SC instruction to
any memory operations following the branch. PPO
rule <a href="#ppo">11</a> in turn implies that any subsequent store
operations will appear later in the global memory order than the store
operation generated by the SC. However, since control, address, and data
dependencies are defined over memory operations, and since an
unsuccessful SC does not generate a memory operation, no order is
enforced between unsuccessful SC and its dependent instructions.
Moreover, since SC is defined to carry dependencies from its source
registers to <em>rd</em> only when the SC is successful, an unsuccessful SC has
no effect on the global memory order.</p>
</div>
<table id="litmus_lb_lrsc" class="tableblock frame-none grid-none stretch center">
<caption class="title">Table 8. A variant of the LB litmus test (outcome forbidden)</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">Initial values: 0(s0)=1; 0(s2)=1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">Hart 0</p></td>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">Hart 1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ld a0,0(s0)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(e)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ld a3,0(s2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lr a1,0(s1)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(f)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sd a3,0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(c)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sc a2,a0,0(s1)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sd a2,0(s2)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">Outcome: <code>a0=0</code>, <code>a3=0</code></p></td>
</tr>
</tbody>
</table></div></td>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="_images/graphviz/litmus_lb_lrsc.png" alt="litmus lb lrsc"></span></p></td>
</tr>
</tbody>
</table></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In addition, the choice to respect dependencies originating at
store-conditional instructions ensures that certain out-of-thin-air-like
behaviors will be prevented. Consider
<a href="#litmus_lb_lrsc">A variant of the LB litmus test (outcome forbidden)</a>. Suppose a
hypothetical implementation could occasionally make some early guarantee
that a store-conditional operation will succeed. In this case, (c) could
return 0 to <code>a2</code> early (before actually executing), allowing the
sequence (d), (e), (f), (a), and then (b) to execute, and then (c) might
execute (successfully) only at that point. This would imply that (c)
writes its own success value to <code>0(s1)</code>! Fortunately, this situation and
others like it are prevented by the fact that RVWMO respects
dependencies originating at the stores generated by successful SC
instructions.</p>
</div>
<div class="paragraph">
<p>We also note that syntactic dependencies between instructions only have
any force when they take the form of a syntactic address, control,
and/or data dependency. For example: a syntactic dependency between two
<code>F</code> instructions via one of the <code>accumulating CSRs</code> in
<a href="#source-dest-regs">[source-dest-regs]</a> does <em>not</em> imply
that the two <code>F</code> instructions must be executed in order. Such a
dependency would only serve to ultimately set up later a dependency from
both <code>F</code> instructions to a later CSR instruction accessing the CSR
flag in question.</p>
</div>
</div>
<div class="sect3">
<h4 id="memory-ppopipeline"><a class="anchor" href="#memory-ppopipeline"></a>Pipeline Dependencies (<a href="#overlapping-ordering">Rules 12-13</a>)</h4>
<div id="addrdatarfi" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#overlapping-ordering">Rule 12</a>: b is a load, and there exists some store m between a and b in
program order such that m has an address or data dependency on a,
and b returns a value written by m</p>
</div>
<div class="paragraph">
<p><a href="#overlapping-ordering">Rule 13</a>: b is a store, and there exists some instruction m between a and
b in program order such that m has an address dependency on a</p>
</div>
</td>
</tr>
</table>
</div>
<table id="litmus_datarfi" class="tableblock frame-none grid-none stretch center">
<caption class="title">Table 9. Because of PPO <a href="#overlapping-ordering">rule 12</a> and the data dependency from (d) to (e), (d) must also precede (f) in the global memory order (outcome forbidden)</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Hart 0</th>
<th class="tableblock halign-left valign-top" colspan="2">Hart 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">li t1, 1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a0, 0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s0)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(e)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw a0, 0(s2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fence w, w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(f)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a1, 0(s2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(c)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s1)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xor a2,a1,a1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">add s0,s0,a2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(g)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a3,0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">Outcome: <code>a0=1</code>, <code>a3=0</code></p></td>
</tr>
</tbody>
</table></div></td>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="_images/graphviz/litmus_datarfi.png" alt="litmus datarfi"></span></p></td>
</tr>
</tbody>
</table></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>PPO rules <a href="#overlapping-ordering">12</a> and <a href="#overlapping-ordering">13</a> reflect behaviors of almost all real processor
pipeline implementations. Rule <a href="#overlapping-ordering">12</a>
states that a load cannot forward from a store until the address and
data for that store are known. Consider <a href="#litmus_datarfi">Because of PPO rule 12 and the data dependency from (d) to (e), (d) must also precede (f) in the global memory order (outcome forbidden)</a> (f) cannot be
executed until the data for (e) has been resolved, because (f) must
return the value written by (e) (or by something even later in the
global memory order), and the old value must not be clobbered by the
write-back of (e) before (d) has had a chance to perform. Therefore, (f)
will never perform before (d) has performed.</p>
</div>
<table class="tableblock frame-none grid-none stretch center">
<caption class="title">Table 10. Because of the extra store between (e) and (g), (d) no longer necessarily precedes (g) (outcome permitted)</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Hart 0</th>
<th class="tableblock halign-left valign-top" colspan="2">Hart 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t1, 1</p></td>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t1, 1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s0)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a0, 0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fence w, w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(e)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw a0, 0(s2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(c)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s1)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(f)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1, 0(s2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(g)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a1, 0(s2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xor a2,a1,a1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">add s0,s0,a2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(h)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a3,0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">Outcome: <code>a0=1</code>, <code>a3=0</code></p></td>
</tr>
</tbody>
</table></div></td>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="_images/graphviz/litmus_datacoirfi.png" alt="litmus datacoirfi"></span></p></td>
</tr>
</tbody>
</table></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If there were another store to the same address in between (e) and (f),
as in <a href="#litmus:addrdatarfi_no">Because of the address dependency from (d) to (e), (d) also precedes (f) (outcome forbidden)</a>,
then (f) would no longer be dependent on the data of (e) being resolved,
and hence the dependency of (f) on (d), which produces the data for (e),
would be broken.</p>
</div>
<div class="paragraph">
<p>Rule <a href="#overlapping-ordering">13</a> makes a similar observation to the
previous rule: a store cannot be performed at memory until all previous
loads that might access the same address have themselves been performed.
Such a load must appear to execute before the store, but it cannot do so
if the store were to overwrite the value in memory before the load had a
chance to read the old value. Likewise, a store generally cannot be
performed until it is known that preceding instructions will not cause
an exception due to failed address resolution, and in this sense,
rule 13 can be seen as somewhat of a special case
of rule <a href="#overlapping-ordering">11</a>.</p>
</div>
<table id="litmus:addrdatarfi_no" class="tableblock frame-none grid-none stretch center">
<caption class="title">Table 11. Because of the address dependency from (d) to (e), (d) also precedes (f) (outcome forbidden)</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Hart 0</th>
<th class="tableblock halign-center valign-top" colspan="2">Hart 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"></td>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t1, 1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a0,0(s0)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a1, 0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fence rw,rw</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(e)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a2, 0(a1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(c)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw s2,0(s1)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(f)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1, 0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">Outcome: <code>a0=1</code>, <code>a1=t</code></p></td>
</tr>
</tbody>
</table></div></td>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="_images/graphviz/litmus_addrpo.png" alt="litmus addrpo"></span></p></td>
</tr>
</tbody>
</table></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Consider <a href="#litmus:addrdatarfi_no">Because of the address dependency from (d) to (e), (d) also precedes (f) (outcome forbidden)</a> (f) cannot be
executed until the address for (e) is resolved, because it may turn out
that the addresses match; i.e., that <code>a1=s0</code>. Therefore, (f) cannot be
sent to memory before (d) has executed and confirmed whether the
addresses do indeed overlap.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beyond-main-memory"><a class="anchor" href="#beyond-main-memory"></a>Beyond Main Memory</h3>
<div class="paragraph">
<p>RVWMO does not currently attempt to formally describe how FENCE.I,
SFENCE.VMA, I/O fences, and PMAs behave. All of these behaviors will be
described by future formalizations. In the meantime, the behavior of
FENCE.I is described in <a href="zifencei.html" class="xref page">zifencei.adoc</a>, the
behavior of SFENCE.VMA is described in the RISC-V Instruction Set
Privileged Architecture Manual, and the behavior of I/O fences and the
effects of PMAs are described below.</p>
</div>
<div class="sect3">
<h4 id="coherence-and-cacheability"><a class="anchor" href="#coherence-and-cacheability"></a>Coherence and Cacheability</h4>
<div class="paragraph">
<p>The RISC-V Privileged ISA defines Physical Memory Attributes (PMAs)
which specify, among other things, whether portions of the address space
are coherent and/or cacheable. See the RISC-V Privileged ISA
Specification for the complete details. Here, we simply discuss how the
various details in each PMA relate to the memory model:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Main memory vs.I/O, and I/O memory ordering PMAs: the memory model as
defined applies to main memory regions. I/O ordering is discussed below.</p>
</li>
<li>
<p>Supported access types and atomicity PMAs: the memory model is simply
applied on top of whatever primitives each region supports.</p>
</li>
<li>
<p>Cacheability PMAs: the cacheability PMAs in general do not affect the
memory model. Non-cacheable regions may have more restrictive behavior
than cacheable regions, but the set of allowed behaviors does not change
regardless. However, some platform-specific and/or device-specific
cacheability settings may differ.</p>
</li>
<li>
<p>Coherence PMAs: The memory consistency model for memory regions marked
as non-coherent in PMAs is currently platform-specific and/or
device-specific: the load-value axiom, the atomicity axiom, and the
progress axiom all may be violated with non-coherent memory. Note
however that coherent memory does not require a hardware cache coherence
protocol. The RISC-V Privileged ISA Specification suggests that
hardware-incoherent regions of main memory are discouraged, but the
memory model is compatible with hardware coherence, software coherence,
implicit coherence due to read-only memory, implicit coherence due to
only one agent having access, or otherwise.</p>
</li>
<li>
<p>Idempotency PMAs: Idempotency PMAs are used to specify memory regions
for which loads and/or stores may have side effects, and this in turn is
used by the microarchitecture to determine, e.g., whether prefetches are
legal. This distinction does not affect the memory model.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="io-ordering"><a class="anchor" href="#io-ordering"></a>I/O Ordering</h4>
<div class="paragraph">
<p>For I/O, the load value axiom and atomicity axiom in general do not
apply, as both reads and writes might have device-specific side effects
and may return values other than the value "written" by the most
recent store to the same address. Nevertheless, the following preserved
program order rules still generally apply for accesses to I/O memory:
memory access <em>a</em> precedes memory access <em>b</em> in
global memory order if <em>a</em> precedes <em>b</em> in
program order and one or more of the following holds:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>a</em> precedes <em>b</em> in preserved program order as
defined in <a href="rvwmo.html" class="xref page">"RVWMO Memory Consistency Model</a>, with the exception
that acquire and release ordering annotations apply only from one memory
operation to another memory operation and from one I/O operation to
another I/O operation, but not from a memory operation to an I/O nor
vice versa</p>
</li>
<li>
<p><em>a</em> and <em>b</em> are accesses to overlapping
addresses in an I/O region</p>
</li>
<li>
<p><em>a</em> and <em>b</em> are accesses to the same strongly
ordered I/O region</p>
</li>
<li>
<p><em>a</em> and <em>b</em> are accesses to I/O regions, and
the channel associated with the I/O region accessed by either
<em>a</em> or <em>b</em> is channel 1</p>
</li>
<li>
<p><em>a</em> and <em>b</em> are accesses to I/O regions
associated with the same channel (except for channel 0)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that the FENCE instruction distinguishes between main memory
operations and I/O operations in its predecessor and successor sets. To
enforce ordering between I/O operations and main memory operations, code
must use a FENCE with PI, PO, SI, and/or SO, plus PR, PW, SR, and/or SW.
For example, to enforce ordering between a write to main memory and an
I/O write to a device register, a FENCE W,O or stronger is needed.</p>
</div>
<div id="wo" class="listingblock text-center">
<div class="title">Ordering memory and I/O accesses</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-source%linenums hljs" data-lang="source%linenums">sd t0, 0(a0)
fence w,o
sd a0, 0(a1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a fence is in fact used, implementations must assume that the
device may attempt to access memory immediately after receiving the MMIO
signal, and subsequent memory accesses from that device to memory must
observe the effects of all accesses ordered prior to that MMIO
operation. In other words, in <a href="#wo">Ordering memory and I/O accesses</a>,
suppose <code>0(a0)</code> is in main memory and <code>0(a1)</code> is the address of a device
register in I/O memory. If the device accesses <code>0(a0)</code> upon receiving
the MMIO write, then that load must conceptually appear after the first
store to <code>0(a0)</code> according to the rules of the RVWMO memory model. In
some implementations, the only way to ensure this will be to require
that the first store does in fact complete before the MMIO write is
issued. Other implementations may find ways to be more aggressive, while
others still may not need to do anything different at all for I/O and
main memory accesses. Nevertheless, the RVWMO memory model does not
distinguish between these options; it simply provides an
implementation-agnostic mechanism to specify the orderings that must be
enforced.</p>
</div>
<div class="paragraph">
<p>Many architectures include separate notions of "ordering" and
`completion" fences, especially as it relates to I/O (as opposed to
regular main memory). Ordering fences simply ensure that memory
operations stay in order, while completion fences ensure that
predecessor accesses have all completed before any successors are made
visible. RISC-V does not explicitly distinguish between ordering and
completion fences. Instead, this distinction is simply inferred from
different uses of the FENCE bits.</p>
</div>
<div class="paragraph">
<p>For implementations that conform to the RISC-V Unix Platform
Specification, I/O devices and DMA operations are required to access
memory coherently and via strongly ordered I/O channels. Therefore,
accesses to regular main memory regions that are concurrently accessed
by external devices can also use the standard synchronization
mechanisms. Implementations that do not conform to the Unix Platform
Specification and/or in which devices do not access memory coherently
will need to use mechanisms (which are currently platform-specific or
device-specific) to enforce coherency.</p>
</div>
<div class="paragraph">
<p>I/O regions in the address space should be considered non-cacheable
regions in the PMAs for those regions. Such regions can be considered
coherent by the PMA if they are not cached by any agent.</p>
</div>
<div class="paragraph">
<p>The ordering guarantees in this section may not apply beyond a
platform-specific boundary between the RISC-V cores and the device. In
particular, I/O accesses sent across an external bus (e.g., PCIe) may be
reordered before they reach their ultimate destination. Ordering must be
enforced in such situations according to the platform-specific rules of
those external devices and buses.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="memory_porting"><a class="anchor" href="#memory_porting"></a>Code Porting and Mapping Guidelines</h3>
<table id="tsomappings" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 12. Mappings from TSO operations to RISC-V operations</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">x86/TSO Operation</th>
<th class="tableblock halign-left valign-top">RVWMO Mapping</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Load</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>l{b|h|w|d}; fence r,rw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Store</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw,w; s{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Atomic RMW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo&lt;op&gt;.{w|d}.aqrl OR</code><br>
<code>loop:lr.{w|d}.aq; &lt;op&gt;; sc.{w|d}.aqrl; bnez loop</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fence</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw,rw</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><a href="#tsomappings">Mappings from TSO operations to RISC-V operations</a> provides a mapping from TSO memory
operations onto RISC-V memory instructions. Normal x86 loads and stores
are all inherently acquire-RCpc and release-RCpc operations: TSO
enforces all load-load, load-store, and store-store ordering by default.
Therefore, under RVWMO, all TSO loads must be mapped onto a load
followed by FENCE R,RW, and all TSO stores must be mapped onto
FENCE RW,W followed by a store. TSO atomic read-modify-writes and x86
instructions using the LOCK prefix are fully ordered and can be
implemented either via an AMO with both <em>aq</em> and <em>rl</em> set, or via an LR
with <em>aq</em> set, the arithmetic operation in question, an SC with both
<em>aq</em> and <em>rl</em> set, and a conditional branch checking the success
condition. In the latter case, the <em>rl</em> annotation on the LR turns out
(for non-obvious reasons) to be redundant and can be omitted.</p>
</div>
<div class="paragraph">
<p>Alternatives to <a href="#tsomappings">Mappings from TSO operations to RISC-V operations</a> are also possible. A TSO
store can be mapped onto AMOSWAP with <em>rl</em> set. However, since RVWMO PPO
Rule <a href="#overlapping-ordering">3</a> forbids forwarding of values from
AMOs to subsequent loads, the use of AMOSWAP for stores may negatively
affect performance. A TSO load can be mapped using LR with <em>aq</em> set: all
such LR instructions will be unpaired, but that fact in and of itself
does not preclude the use of LR for loads. However, again, this mapping
may also negatively affect performance if it puts more pressure on the
reservation mechanism than was originally intended.</p>
</div>
<table id="powermappings" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 13. Mappings from Power operations to RISC-V operations</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Power Operation</th>
<th class="tableblock halign-left valign-top">RVWMO Mapping</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Load</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>l{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Load-Reserve</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lr.{w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Store</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Store-Conditional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sc.{w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lwsync</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence.tso</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sync</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw,rw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isync</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence.i; fence r,r</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><a href="#powermappings">Mappings from Power operations to RISC-V operations</a> provides a mapping from Power memory
operations onto RISC-V memory instructions. Power ISYNC maps on RISC-V
to a FENCE.I followed by a FENCE R,R; the latter fence is needed because
ISYNC is used to define a "control+control fence" dependency that is
not present in RVWMO.</p>
</div>
<table id="armmappings" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 14. Mappings from ARM operations to RISC-V operations</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ARM Operation</th>
<th class="tableblock halign-left valign-top">RVWMO Mapping</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Load</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>l{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Load-Acquire</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw, rw; l{b|h|w|d}; fence r,rw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Load-Exclusive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lr.{w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Load-Acquire-Exclusive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lr.{w|d}.aqrl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Store</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Store-Release</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw,w; s{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Store-Exclusive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sc.{w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Store-Release-Exclusive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sc.{w|d}.rl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dmb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw,rw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dmb.ld</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence r,rw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dmb.st</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence w,w</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence.i; fence r,r</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><a href="#armmappings">Mappings from ARM operations to RISC-V operations</a> provides a mapping from ARM memory
operations onto RISC-V memory instructions. Since RISC-V does not
currently have plain load and store opcodes with <em>aq</em> or <em>rl</em>
annotations, ARM load-acquire and store-release operations should be
mapped using fences instead. Furthermore, in order to enforce
store-release-to-load-acquire ordering, there must be a FENCE RW,RW
between the store-release and load-acquire; <a href="#armmappings">Mappings from ARM operations to RISC-V operations</a>
enforces this by always placing the fence in front of each acquire
operation. ARM load-exclusive and store-exclusive instructions can
likewise map onto their RISC-V LR and SC equivalents, but instead of
placing a FENCE RW,RW in front of an LR with <em>aq</em> set, we simply also
set <em>rl</em> instead. ARM ISB maps on RISC-V to FENCE.I followed by
FENCE R,R similarly to how ISYNC maps for Power.</p>
</div>
<table id="linuxmappings" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 15. Mappings from Linux memory primitives to RISC-V primitives.</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Linux Operation</th>
<th class="tableblock halign-left valign-top">RVWMO Mapping</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>smp_mb()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw,rw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>smp_rmb()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence r,r</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>smp_wmb()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence w,w</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dma_rmb()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence r,r</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dma_wmb()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence w,w</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mb()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence iorw,iorw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rmb()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence ri,ri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>wmb()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence wo,wo</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>smp_load_acquire()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>l{b|h|w|d}; fence r,rw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>smp_store_release()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence.tso; s{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Linux Construct</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RVWMO AMO Mapping</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic &#60;op&#62; relaxed</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo &#60;op&#62;.{w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic &#60;op&#62; acquire</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo &#60;op&#62;.{w|d}.aq</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic &#60;op&#62; release</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo &#60;op&#62;.{w|d}.rl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic &#60;op&#62;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo &#60;op&#62;.{w|d}.aqrl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Linux Construct</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RVWMO LR/SC Mapping</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic &#60;op&#62; relaxed</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loop:lr.{w|d}; &#60;op&#62;; sc.{w|d}; bnez loop</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic &#60;op&#62; acquire</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loop:lr.{w|d}.aq; &#60;op&#62;; sc.{w|d}; bnez loop</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic &#60;op&#62; release</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loop:lr.{w|d}; &#60;op&#62;; sc.{w|d}.aqrl^&#42;; bnez loop OR</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence.tso; loop:lr.{w|d}; &#60;op &#62;; sc.{w|d}^&#42;; bnez loop</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic &#60;op&#62;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loop:lr.{w|d}.aq;</code> <code>&#60;op&#62;; sc.{w|d}.aqrl; bnez loop</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>With regards to <a href="#linuxmappings">Mappings from Linux memory primitives to RISC-V primitives.</a>, other
constructs (such as spinlocks) should follow accordingly. Platforms or
devices with non-coherent DMA may need additional synchronization (such
as cache flush or invalidate mechanisms); currently any such extra
synchronization will be device-specific.</p>
</div>
<div class="paragraph">
<p><a href="#linuxmappings">Mappings from Linux memory primitives to RISC-V primitives.</a> provides a mapping of Linux memory
ordering macros onto RISC-V memory instructions. The Linux fences
<code>dma_rmb()</code> and <code>dma_wmb()</code> map onto FENCE R,R and FENCE W,W,
respectively, since the RISC-V Unix Platform requires coherent DMA, but
would be mapped onto FENCE RI,RI and FENCE WO,WO, respectively, on a
platform with non-coherent DMA. Platforms with non-coherent DMA may also
require a mechanism by which cache lines can be flushed and/or
invalidated. Such mechanisms will be device-specific and/or standardized
in a future extension to the ISA.</p>
</div>
<div class="paragraph">
<p>The Linux mappings for release operations may seem stronger than
necessary, but these mappings are needed to cover some cases in which
Linux requires stronger orderings than the more intuitive mappings would
provide. In particular, as of the time this text is being written, Linux
is actively debating whether to require load-load, load-store, and
store-store orderings between accesses in one critical section and
accesses in a subsequent critical section in the same hart and protected
by the same synchronization object. Not all combinations of
FENCE RW,W/FENCE R,RW mappings with <em>aq</em>/<em>rl</em> mappings combine to
provide such orderings. There are a few ways around this problem,
including:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Always use FENCE RW,W/FENCE R,RW, and never use <em>aq</em>/<em>rl</em>. This
suffices but is undesirable, as it defeats the purpose of the <em>aq</em>/<em>rl</em>
modifiers.</p>
</li>
<li>
<p>Always use <em>aq</em>/<em>rl</em>, and never use FENCE RW,W/FENCE R,RW. This does
not currently work due to the lack of load and store opcodes with <em>aq</em>
and <em>rl</em> modifiers.</p>
</li>
<li>
<p>Strengthen the mappings of release operations such that they would
enforce sufficient orderings in the presence of either type of acquire
mapping. This is the currently recommended solution, and the one shown
in <a href="#linuxmappings">Mappings from Linux memory primitives to RISC-V primitives.</a>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>RVWMO Mapping: (a) lw a0, 0(s0) (b) fence.tso // vs. fence rw,w (c) sd
x0,0(s1) &#8230;&#8203; loop: (d) amoswap.d.aq a1,t1,0(s1) bnez a1,loop (e) lw
a2,0(s2)</p>
</div>
<div class="paragraph">
<p>For example, the critical section ordering rule currently being debated
by the Linux community would require (a) to be ordered before (e) in
<a href="#lkmm_ll">Orderings between critical sections in Linux</a>. If that will indeed be
required, then it would be insufficient for (b) to map as FENCE RW,W.
That said, these mappings are subject to change as the Linux Kernel
Memory Model evolves.</p>
</div>
<div id="lkmm_ll" class="listingblock">
<div class="title">Orderings between critical sections in Linux</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-asm hljs" data-lang="asm">Linux Code:
(a) int r0 = *x;
       (bc) spin_unlock(y, 0);
....
....
(d) spin_lock(y);
(e) int r1 = *z;

RVWMO Mapping:
(a) lw a0, 0(s0)
(b) fence.tso // vs. fence rw,w
(c) sd x0,0(s1)
....
loop:
(d) lr.d.aq a1,(s1)
bnez a1,loop
sc.d a1,t1,(s1)
bnez a1,loop
(e) lw a2,0(s2)</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#c11mappings">Mappings from C/C++ primitives to RISC-V primitives.</a> provides a mapping of C11/C++11 atomic
operations onto RISC-V memory instructions. If load and store opcodes
with <em>aq</em> and <em>rl</em> modifiers are introduced, then the mappings in
<a href="#c11mappings_hypothetical">Hypothetical mappings from C/C++ primitives to RISC-V primitives, if native load-acquire and store-release opcodes are introduced.</a> will suffice. Note however that
the two mappings only interoperate correctly if
<code>atomic_&lt;op&gt;(memory_order_seq_cst)</code> is mapped using an LR that has both
<em>aq</em> and <em>rl</em> set.
Even more importantly, a <a href="#c11mappings">Mappings from C/C++ primitives to RISC-V primitives.</a> sequentially consistent store,
followed by a <a href="#c11mappings_hypothetical">Hypothetical mappings from C/C++ primitives to RISC-V primitives, if native load-acquire and store-release opcodes are introduced.</a> sequentially consistent load
can be reordered unless the <a href="#c11mappings">Mappings from C/C++ primitives to RISC-V primitives.</a> mapping of stores is
strengthened by either adding a second fence or mapping the store
to <code>amoswap.rl</code> instead.</p>
</div>
<table id="c11mappings" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 16. Mappings from C/C++ primitives to RISC-V primitives.</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">C/C++ Construct</th>
<th class="tableblock halign-left valign-top">RVWMO Mapping</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Non-atomic load</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>l{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_load(memory_order_relaxed)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>l{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_load(memory_order_acquire)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>l{b|h|w|d}; fence r,rw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_load(memory_order_seq_cst)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw,rw; l{b|h|w|d}; fence r,rw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Non-atomic store</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_store(memory_order_relaxed)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_store(memory_order_release)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw,w; s{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_store(memory_order_seq_cst)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw,w; s{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_thread_fence(memory_order_acquire)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence r,rw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_thread_fence(memory_order_release)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw,w</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_thread_fence(memory_order_acq_rel)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence.tso</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_thread_fence(memory_order_seq_cst)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw,rw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C/C++ Construct</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RVWMO AMO Mapping</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_relaxed)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo&lt;op&gt;.{w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_acquire)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo&lt;op&gt;.{w|d}.aq</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_release)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo&lt;op&gt;.{w|d}.rl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_acq_rel)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo&lt;op&gt;.{w|d}.aqrl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_seq_cst)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo&lt;op&gt;.{w|d}.aqrl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C/C++ Construct</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RVWMO LR/SC Mapping</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_relaxed)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loop:lr.{w|d}; &lt;op&gt;; sc.{w|d};</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bnez loop</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_acquire)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loop:lr.{w|d}.aq; &lt;op&gt;; sc.{w|d};</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bnez loop</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_release)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loop:lr.{w|d}; &lt;op&gt;; sc.{w|d}.rl;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bnez loop</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_acq_rel)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loop:lr.{w|d}.aq; &lt;op&gt;; sc.{w|d}.rl;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bnez loop</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_seq_cst)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loop:lr.{w|d}.aqrl; &lt;op&gt;;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sc.{w|d}.rl; bnez loop</code></p></td>
</tr>
</tbody>
</table>
<table id="c11mappings_hypothetical" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 17. Hypothetical mappings from C/C++ primitives to RISC-V primitives, if native load-acquire and store-release opcodes are introduced.</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">C/C++ Construct</th>
<th class="tableblock halign-left valign-top">RVWMO Mapping</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Non-atomic load</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>l{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_load(memory_order_relaxed)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>l{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_load(memory_order_acquire)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>l{b|h|w|d}.aq</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_load(memory_order_seq_cst)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>l{b|h|w|d}.aq</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Non-atomic store</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_store(memory_order_relaxed)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s{b|h|w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_store(memory_order_release)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s{b|h|w|d}.rl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_store(memory_order_seq_cst)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s{b|h|w|d}.rl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_thread_fence(memory_order_acquire)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence r,rw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_thread_fence(memory_order_release)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw,w</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_thread_fence(memory_order_acq_rel)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence.tso</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_thread_fence(memory_order_seq_cst)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence rw,rw</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C/C++ Construct</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RVWMO AMO Mapping</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_relaxed)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo&lt;op&gt;.{w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_acquire)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo&lt;op&gt;.{w|d}.aq</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_release)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo&lt;op&gt;.{w|d}.rl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_acq_rel)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo&lt;op&gt;.{w|d}.aqrl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_seq_cst)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amo&lt;op&gt;.{w|d}.aqrl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C/C++ Construct</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RVWMO LR/SC Mapping</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_relaxed)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lr.{w|d}; &lt;op&gt;; sc.{w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_acquire)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lr.{w|d}.aq; &lt;op&gt;; sc.{w|d}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_release)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lr.{w|d}; &lt;op&gt;; sc.{w|d}.rl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_acq_rel)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lr.{w|d}.aq; &lt;op&gt;; sc.{w|d}.rl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>atomic_&lt;op&gt;(memory_order_seq_cst)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lr.{w|d}.aq* &lt;op&gt;; sc.{w|d}.rl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock"><code>*</code> must be <code>lr.{w|d}.aqrl</code> in order to interoperate with code mapped per <a href="#c11mappings">Mappings from C/C++ primitives to RISC-V primitives.</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Any AMO can be emulated by an LR/SC pair, but care must be taken to
ensure that any PPO orderings that originate from the LR are also made
to originate from the SC, and that any PPO orderings that terminate at
the SC are also made to terminate at the LR. For example, the LR must
also be made to respect any data dependencies that the AMO has, given
that load operations do not otherwise have any notion of a data
dependency. Likewise, the effect a FENCE R,R elsewhere in the same hart
must also be made to apply to the SC, which would not otherwise respect
that fence. The emulator may achieve this effect by simply mapping AMOs
onto <code>lr.aq; &lt;op&gt;; sc.aqrl</code>, matching the mapping used elsewhere for
fully ordered atomics.</p>
</div>
<div class="paragraph">
<p>These C11/C++11 mappings require the platform to provide the following
Physical Memory Attributes (as defined in the RISC-V Privileged ISA) for
all memory:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>main memory</p>
</li>
<li>
<p>coherent</p>
</li>
<li>
<p>AMOArithmetic</p>
</li>
<li>
<p>RsrvEventual</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Platforms with different attributes may require different mappings, or
require platform-specific SW (e.g., memory-mapped I/O).</p>
</div>
</div>
<div class="sect2">
<h3 id="implementation-guidelines"><a class="anchor" href="#implementation-guidelines"></a>Implementation Guidelines</h3>
<div class="paragraph">
<p>The RVWMO and RVTSO memory models by no means preclude
microarchitectures from employing sophisticated speculation techniques
or other forms of optimization in order to deliver higher performance.
The models also do not impose any requirement to use any one particular
cache hierarchy, nor even to use a cache coherence protocol at all.
Instead, these models only specify the behaviors that can be exposed to
software. Microarchitectures are free to use any pipeline design, any
coherent or non-coherent cache hierarchy, any on-chip interconnect,
etc., as long as the design only admits executions that satisfy the
memory model rules. That said, to help people understand the actual
implementations of the memory model, in this section we provide some
guidelines on how architects and programmers should interpret the
models' rules.</p>
</div>
<div class="paragraph">
<p>Both RVWMO and RVTSO are multi-copy atomic (or
<em>other-multi-copy-atomic</em>): any store value that is visible to a hart
other than the one that originally issued it must also be conceptually
visible to all other harts in the system. In other words, harts may
forward from their own previous stores before those stores have become
globally visible to all harts, but no early inter-hart forwarding is
permitted. Multi-copy atomicity may be enforced in a number of ways. It
might hold inherently due to the physical design of the caches and store
buffers, it may be enforced via a single-writer/multiple-reader cache
coherence protocol, or it might hold due to some other mechanism.</p>
</div>
<div class="paragraph">
<p>Although multi-copy atomicity does impose some restrictions on the
microarchitecture, it is one of the key properties keeping the memory
model from becoming extremely complicated. For example, a hart may not
legally forward a value from a neighbor hart&#8217;s private store buffer
(unless of course it is done in such a way that no new illegal behaviors
become architecturally visible). Nor may a cache coherence protocol
forward a value from one hart to another until the coherence protocol
has invalidated all older copies from other caches. Of course,
microarchitectures may (and high-performance implementations likely
will) violate these rules under the covers through speculation or other
optimizations, as long as any non-compliant behaviors are not exposed to
the programmer.</p>
</div>
<div class="paragraph">
<p>As a rough guideline for interpreting the PPO rules in RVWMO, we expect
the following from the software perspective:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>programmers will use PPO rules <a href="#overlapping-ordering">1</a> and <a href="#overlapping-ordering">4-8</a> regularly and actively.</p>
</li>
<li>
<p>expert programmers will use PPO rules <a href="#overlapping-ordering">9-11</a> to speed up critical paths
of important data structures.</p>
</li>
<li>
<p>even expert programmers will rarely if ever use PPO rules <a href="#overlapping-ordering">2-3</a> and
<a href="#overlapping-ordering">12-13</a> directly.
These are included to facilitate common microarchitectural optimizations
(rule <a href="#overlapping-ordering">2</a>) and the operational formal modeling approach (rules <a href="#overlapping-ordering">3</a> and
<a href="#overlapping-ordering">12-13</a>) described
in <a href="#operational">[operational]</a>. They also facilitate the
process of porting code from other architectures that have similar
rules.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We also expect the following from the hardware perspective:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PPO rules <a href="#overlapping-ordering">1</a> and <a href="#overlapping-ordering">3-6</a> reflect
well-understood rules that should pose few surprises to architects.</p>
</li>
<li>
<p>PPO rule <a href="#overlapping-ordering">2</a> reflects a natural and common hardware
optimization, but one that is very subtle and hence is worth double
checking carefully.</p>
</li>
<li>
<p>PPO rule <a href="#overlapping-ordering">7</a> may not be immediately obvious to
architects, but it is a standard memory model requirement</p>
</li>
<li>
<p>The load value axiom, the atomicity axiom, and PPO rules
<a href="#overlapping-ordering">8-13</a> reflect rules that most
hardware implementations will enforce naturally, unless they contain
extreme optimizations. Of course, implementations should make sure to
double check these rules nevertheless. Hardware must also ensure that
syntactic dependencies are not <code>optimized away</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Architectures are free to implement any of the memory model rules as
conservatively as they choose. For example, a hardware implementation
may choose to do any or all of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>interpret all fences as if they were FENCE RW,RW (or FENCE IORW,IORW,
if I/O is involved), regardless of the bits actually set</p>
</li>
<li>
<p>implement all fences with PW and SR as if they were FENCE RW,RW (or
FENCE IORW,IORW, if I/O is involved), as PW with SR is the most
expensive of the four possible main memory ordering components anyway</p>
</li>
<li>
<p>emulate <em>aq</em> and <em>rl</em> as described in <a href="#memory_porting">Code Porting and Mapping Guidelines</a></p>
</li>
<li>
<p>enforcing all same-address load-load ordering, even in the presence of
patterns such as <code>fri-rfi</code> and <code>RSW</code></p>
</li>
<li>
<p>forbid any forwarding of a value from a store in the store buffer to a
subsequent AMO or LR to the same address</p>
</li>
<li>
<p>forbid any forwarding of a value from an AMO or SC in the store buffer
to a subsequent load to the same address</p>
</li>
<li>
<p>implement TSO on all memory accesses, and ignore any main memory
fences that do not include PW and SR ordering (e.g., as Ztso
implementations will do)</p>
</li>
<li>
<p>implement all atomics to be RCsc or even fully ordered, regardless of
annotation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Architectures that implement RVTSO can safely do the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ignore all fences that do not have both PW and SR (unless the fence
also orders I/O)</p>
</li>
<li>
<p>Ignore all PPO rules except for rules <a href="#overlapping-ordering">4</a> through <a href="#overlapping-ordering">7</a>, since the rest
are redundant with other PPO rules under RVTSO assumptions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other general notes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Silent stores (i.e., stores that write the same value that already
exists at a memory location) behave like any other store from a memory
model point of view. Likewise, AMOs which do not actually change the
value in memory (e.g., an AMOMAX for which the value in <em>rs2</em> is smaller
than the value currently in memory) are still semantically considered
store operations. Microarchitectures that attempt to implement silent
stores must take care to ensure that the memory model is still obeyed,
particularly in cases such as RSW <a href="#mm-overlap">Overlapping-Address Orderings (Rules 1-3)</a>
which tend to be incompatible with silent stores.</p>
</li>
<li>
<p>Writes may be merged (i.e., two consecutive writes to the same address
may be merged) or subsumed (i.e., the earlier of two back-to-back writes
to the same address may be elided) as long as the resulting behavior
does not otherwise violate the memory model semantics.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The question of write subsumption can be understood from the following
example:</p>
</div>
<table class="tableblock frame-none grid-none stretch center">
<caption class="title">Table 18. Write subsumption litmus test, allowed execution</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Hart 0</th>
<th class="tableblock halign-center valign-top" colspan="2">Hart 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t1, 3</p></td>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t3, 2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">li t2, 1</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s0)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a0,0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fence w, w</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(e)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw a0,0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(c)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t2,0(s1)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(f)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t3,0(s0)</p></td>
</tr>
</tbody>
</table></div></td>
<td class="tableblock halign-left valign-middle"><div class="content"><table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="_images/graphviz/litmus_subsumption.png" alt="litmus subsumption"></span></p></td>
</tr>
</tbody>
</table></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>As written, if the load  (d) reads value <em>1</em>, then (a) must
precede (f) in the global memory order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(a) precedes (c) in the global memory order because of rule 4</p>
</li>
<li>
<p>(c) precedes (d) in the global memory order because of the Load
Value axiom</p>
</li>
<li>
<p>(d) precedes (e) in the global memory order because of rule 10</p>
</li>
<li>
<p>(e) precedes (f) in the global memory order because of rule 1</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In other words the final value of the memory location whose address is
in <code>s0</code> must be <em>2</em> (the value written by the store (f)) and
cannot be <em>3</em> (the value written by the store (a)).</p>
</div>
<div class="paragraph">
<p>A very aggressive microarchitecture might erroneously decide to discard
(e), as (f) supersedes it, and this may in turn lead the
microarchitecture to break the now-eliminated dependency between (d) and
(f) (and hence also between (a) and (f)). This would violate the memory
model rules, and hence it is forbidden. Write subsumption may in other
cases be legal, if for example there were no data dependency between (d)
and (e).</p>
</div>
<div class="sect3">
<h4 id="possible-future-extensions"><a class="anchor" href="#possible-future-extensions"></a>Possible Future Extensions</h4>
<div class="paragraph">
<p>We expect that any or all of the following possible future extensions
would be compatible with the RVWMO memory model:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>"V" vector ISA extensions</p>
</li>
<li>
<p>"J" JIT extension</p>
</li>
<li>
<p>Native encodings for load and store opcodes with <em>aq</em> and <em>rl</em> set</p>
</li>
<li>
<p>Fences limited to certain addresses</p>
</li>
<li>
<p>Cache write-back/flush/invalidate/etc.instructions</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="discrepancies"><a class="anchor" href="#discrepancies"></a>Known Issues</h3>
<div class="sect3">
<h4 id="mixedrsw"><a class="anchor" href="#mixedrsw"></a>Mixed-size RSW</h4>
<table id="rsw1" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 19. Mixed-size discrepancy (permitted by axiomatic models, forbidden by operational model)</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Hart 0</th>
<th class="tableblock halign-center valign-top" colspan="2">Hart 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t1, 1</p></td>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t1, 1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a0,0(s0)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a1,0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fence rw,rw</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(e)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">amoswap.w.rl a2,t1,0(s2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(c)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s1)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(f)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ld a3,0(s2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(g)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a4,4(s2)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xor a5,a4,a4</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">add s0,s0,a5</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(h)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">Outcome: <code>a0=1</code>, <code>a1=1</code>, <code>a2=0</code>, <code>a3=1</code>, <code>a4=0</code></p></td>
</tr>
</tbody>
</table>
<table id="rsw2" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 20. Mixed-size discrepancy (permitted by axiomatic models, forbidden by operational model)</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Hart 0</th>
<th class="tableblock halign-center valign-top" colspan="2">Hart 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t1, 1</p></td>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t1, 1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a0,0(s0)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ld a1,0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fence rw,rw</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(e)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a2,4(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(c)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s1)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xor a3,a2,a2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">add s0,s0,a3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(f)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">Outcome: <code>a0=1</code>, <code>a1=1</code>, <code>a2=0</code></p></td>
</tr>
</tbody>
</table>
<table id="rsw3" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 21. Mixed-size discrepancy (permitted by axiomatic models, forbidden by operational model)</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Hart 0</th>
<th class="tableblock halign-center valign-top" colspan="2">Hart 1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t1, 1</p></td>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">li t1, 1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a0,0(s0)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,4(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fence rw,rw</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(e)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ld a1,0(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">(c)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s1)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(f)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lw a2,4(s1)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xor a3,a2,a2</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">add s0,s0,a3</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">(g)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sw t1,0(s0)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4"><p class="tableblock">Outcome: <code>a0=1</code>, <code>a1=0x100000001</code>, <code>a2=1</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>There is a known discrepancy between the operational and axiomatic
specifications within the family of mixed-size RSW variants shown in
<a href="#rsw1">Mixed-size discrepancy (permitted by axiomatic models, forbidden by operational model)</a>-<a href="#rsw3">Mixed-size discrepancy (permitted by axiomatic models, forbidden by operational model)</a>.
To address this, we may choose to add something like the following new
PPO rule: Memory operation <em>a</em> precedes memory operation
<em>b</em> in preserved program order (and hence also in the global
memory order) if <em>a</em> precedes <em>b</em> in program
order, <em>a</em> and <em>b</em> both access regular main
memory (rather than I/O regions), <em>a</em> is a load,
<em>b</em> is a store, there is a load <em>m</em> between
<em>a</em> and <em>b</em>, there is a byte <em>x</em>
that both <em>a</em> and <em>m</em> read, there is no store
between <em>a</em> and <em>m</em> that writes to
<em>x</em>, and <em>m</em> precedes <em>b</em> in PPO. In
other words, in herd syntax, we may choose to add
<code>(po-loc &amp; rsw);ppo;[W]</code> to PPO. Many implementations will already
enforce this ordering naturally. As such, even though this rule is not
official, we recommend that implementers enforce it nevertheless in
order to ensure forwards compatibility with the possible future addition
of this rule to RVWMO.</p>
</div>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="naming.html">ISA Extension Naming Conventions</a></span>
  <span class="next"><a href="mm-formal.html">Appendix B: Formal Memory Model Specifications, Version 0.1</a></span>
</nav>
</article>  </div>
</main>
<div class="modal micromodal-slide" id="modal-versions" aria-hidden="true">
    <div class="modal__overlay" tabindex="-1" data-micromodal-close>
        <div class="modal__container" role="dialog" aria-modal="true">
            <main class="modal__content" id="modal-versions-content">
              <button data-micromodal-close class="modal-versions-close">
                <svg width="28px" height="28px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><defs><style>.cls-1h{fill:none;stroke:#000;stroke-linecap:round;stroke-linejoin:round;stroke-width:2px;}</style></defs><title/><g id="cross"><line class="cls-1h" x1="7" x2="25" y1="7" y2="25"/><line class="cls-1h" x1="7" x2="25" y1="25" y2="7"/></g></svg>
              </button>
                  <ul class="nav-versions">
                      <li class="component">
                        <div>
                          <a class="title" href="../index.html">ISA Specifications</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../index.html">
      default
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                  </ul>
            </main>
        </div>
    </div>
</div>

</div>
<footer class="hidden">
		<script src="../../_/js/vendor/lunr.js"></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css"></script>
<script async src="../../search-index.js"></script>
</footer><script src="../../_/js/vendor/import.js"></script>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script async src="../../_/js/vendor/spring-tabs.js" data-sync-storage-key="docs:preferred-tab"></script>
  </body>
</html>
